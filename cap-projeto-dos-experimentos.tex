%% ------------------------------------------------------------------------- %%
\chapter{Projeto dos experimentos} \label{cap:projeto_dos_experimentos}

%TODO: Simulação x emulação
Este estudo consiste em rodar o sistema de armazenamento dividido entre dois
centros de dados simulados. Os centros de dados são ligados por uma WAN emulada.
A carga de trabalho é executada por uma aplicação de testes simulando clientes
localizados em cada um dos centros de dados. Cada experimento consiste em um
modo do sistema, uma configuração de rede (latência, perda de pacotes, etc) e
uma carga de trabalho (relação leitura/escrita, localidade, etc).

%TODO: Conteúdo das seções


%% ------------------------------------------------------------------------- %%
\section{Aspectos técnicos} \label{sec:aspectos_tecnicos}

O desempenho de um sistema é resultado das suas características (incluindo
arquitetura), do ambiente em que ele opera e da carga de trabalho apresentada. O
ambiente dos experimentos é definido pela plataforma escolhida para executá-los,
descrita na subseção \ref{sec:ambiente}. A forma como a WAN é emulada é descrita
na subseção \ref{sec:rede}. O sistema de armazenamento usado como objeto de
testes, no qual são implementados os modelos de consistência, é descrito na
subseção \ref{sec:sistema_de_armazenamento}.  A carga sobre o sistema é definida
pela aplicação de execução dos testes, descrita na subseção
\ref{sec:aplicacao_de_execucao_dos_testes}. O sistema de armazenamento, a
aplicação de testes e ferramentas de monitoração e análise de desempenho compõem
a imagem, descrita na seção \ref{sec:imagem}. Por fim, a descrição da
infraestrutura de gerenciamento dos experimentos se encontra na seção
\ref{sec:infraestrutura_dos_experimentos}.

%% ------------------------------------------------------------------------- %%
\subsection{Ambiente} \label{sec:ambiente}

Os experimentos foram executados no
Grid5000\footnote{\url{http://www.grid5000.fr/}}, uma plataforma para criação,
execução e monitoramento de experimentos de sistemas paralelos e distribuídos. A
plataforma possui mais de 5000 cores distribuídos em 9 sítios na França e um no
Brasil.

Outras plataformas como o OpenCirrus\footnote{\url{http://opencirrus.org/}} e
PlanetLab\footnote{\url{http://www.planet-lab.org/}} também foram consideradas,
mas foram descartadas por uma questão de conveniência, já que o autor deste
trabalho utilizou o Grid5000 em dois estágios de mestrado de respectivamente
quatro meses e um mês pelo INRIA na França. A experiência no ambiente adquirida
nesse período pode ser reutilizada neste trabalho, tornando o projeto e a
execução dos experimentos mais produtivos. O Amazon Web Services (AWS)
\footnote{\url{http://aws.amazon.com/}} também foi considerado, mas foi
descartado por não ser possível ter controle sobre as características de rede
entre os centros de dados, o que dificultaria a a interpretação dos resultados e
a reprodutibilidade dos experimentos.

A operação no Grid5000 se dá através do acesso ssh ao frontend de cada sítio.
Nele o usuário encontra seu diretório home, onde ele pode armazenar seus scripts
e dados dos experimentos, além de usar as ferramentas do Grid5000.

Dentre as ferramentas mais importantes estão as de reserva e gerenciamento de
máquinas. O Grid5000 é uma infraestrutura compartilhada por diversos
pesquisadores. Portanto, ele oferece um conjunto de ferramentas
(OAR\footnote{\url{http://oar.imag.fr/}}) e regras para que um pesquisador
reserve nós exclusivamente para ele por um determinado período de tempo.  Além
de nós, é possível reservar IPs para compor sub-redes, recurso utilizado nos
experimentos (ver \ref{sec:rede}). Outra ferramenta bastante utilizada é o
kadeploy\footnote{\url{http://kadeploy.imag.fr/}}, responsável pela implantação
de imagens nos nós reservados pelo usuário.

%TODO: Falar do HW

%% ------------------------------------------------------------------------- %%
\subsection{Rede} \label{sec:rede}

Os sítios do Grid5000 são conectados por redes de alta velocidade. Suas redes
apresentam latências da ordem de dezenas de nanosegundos entre nós de um mesmo
aglomerado e da ordem de 20 ms entre sítios, e portanto não caracterizam uma
WAN. De qualquer forma, mesmo que caracterizassem, é importante para este estudo
ter controle sobre esses valores para poder testar os sistema em diferentes
configurações e possibilitar sua reprodutibilidade.

Assim, os experimentos implementam uma latência artificial para simular uma WAN
entre os centros de dados usando a ferramenta traffic control (tc). Essa
ferramenta possibilita a manipulação das filas de saída de pacotes de uma dada
interface de rede do sistema operacional. Mais especificamente para emulação de
WANs, é possível usar o
netem\footnote{\url{http://www.linuxfoundation.org/collaborate/workgroups/networking/}},
que provê funcionalidade para emulação de latência de rede incluindo variação da
latência, perda de pacotes, pacotes duplicados, corrompidos e/ou fora de ordem.
Existem outras ferramentas como o
dummynet\footnote{\url{http://info.iet.unipi.it/~luigi/dummynet/}} e o
NISTNet\footnote{\url{http://snad.ncsl.nist.gov/itg/nistnet/}}, mas elas foram
desconsideradas dado que o netem já vem integrado ao tc e satisfaz os requisitos
funcionais deste estudo.

Existem recomendações sobre otimizações para sistemas Linux quando esses devem
se comunicar usando WANs, dado que a configuração padrão possui foco em LANs.
Durante os experimentos, toda vez em que os parâmetros da WAN eram alterados, um
script para ajuste da pilha TCP era usado. A principal otimização desse script
era ajustar os tamanhos dos buffers de envio e recepção ao BDP (para mais
detalhes, ver seção \ref{sec:fatores_de_rede}).

\paragraph{Simulação de centros de dados}
\label{par:simulacao_de_centros_de_dados}

Os nós que compõem o sistema são divididos em dois conjuntos CD1 e CD2, cada um
representando um centro de dados. Além dos nós, existem duas sub-redes SR1 e
SR2. IPs de SR1 e SR2 são alocados para cada cada nó de CD1 e CD2,
respectivamente. Ao final, cada nó possui dois IPs, o seu IP da rede do Grid5000
e um IP de uma das sub-redes.

Todos os nós no Grid5000 possuem um nome registrado no DNS que aponta para o seu
IP da rede do Grid5000. Nos experimentos dois arquivos /etc/hosts são criados,
um por centro de dados. O objetivo desses arquivos é resolver os nomes dos nós
de cada centro de dados para o IP de sua sub-rede. Cada um desses arquivos é
colocado em todos os nós de cada centro de dados. A partir dessa configuração,
os nós do CD1 resolvem os nomes dos nós do CD2 para os IPs de SR2 e vice-versa.
Como o /etc/hosts tem prioridade sobre o DNS na resolução de nomes, todas as
requisições que saem de um centro de dados para o outro usam o IP daquela
sub-rede, enquanto as requisições para o mesmo centro de dados usam o IP da rede
do Grid5000.

A partir dessa configuração é possível adicionar um filtro baseado em sub-redes
ao tc de modo que as características de WAN são aplicadas às requisições que
saem para o outro centro de dados, enquanto as requisições para a mesma sub-rede
saem inalteradas.

%TODO: dummynet: Marta Carbone and Luigi Rizzo, Dummynet Revisited, ACM SIGCOMM
%Computer Communication Review, 40(2) pg.12-20, March 2010

%% ------------------------------------------------------------------------- %%
\subsection{Sistema de armazenamento} \label{sec:sistema_de_armazenamento}

Uma abordagem para a comparação dos modelos de consistência é o uso de um
sistema de armazenamento já existente que implemente os dois modelos de
consistência, mas tal sistema não foi encontrado. A partir disso, uma segunda
abordagem possível é o uso de sistemas diferentes, cada um implementando um
modelo de consistência. Apesar de existirem experimentos que usam essa abordagem
\cite{Cooper2008,Stonebraker2007,Pavlo2009}, dois problemas foram identificados.
O primeiro é que o desempenho de cada sistema pode ser afetado por fatores
particulares do sistema que não o modelo de consistência, como a tecnologia
utilizada, protocolo de acesso, detalhes de configuração, entre outros. O
segundo é apesar de existirem sistemas de armazenamento de software livre /
código aberto que implementem consistência em momento indeterminado, não foram
encontrados sistemas que implementem consistência na linha do tempo.

A partir disso, os experimentos usam um único sistema, isolando assim o modelo
de consistência como único fator de influência no seu desempenho. Uma opção para
tal é implementar um sistema de armazenamento distribuído específico para os
experimentos. O problema dessa abordagem é que esse tipo de sistema é bastante
complexo, já que precisa prover funcionalidades como controle de entrada e saída
dos nós, algoritmos de particionamento, etc. Desenvolver todas essas
funcionalidades inviabilizaria este trabalho devido ao alto custo em tempo para
implementação.

Para evitar a implementação completa de um sistema de armazenamento, algumas
opções de software livre / código aberto foram analisadas. A seleção das opções
foi feita considerando modelos de consistência, estabilidade da solução e
simplicidade de desenvolvimento. Como não foram encontrados sistemas de
armazenamento de software livre / código aberto que implementem consistência na
linha do tempo, as soluções avaliadas foram aquelas que implementam consistência
em momento indeterminado. Os sistemas encontrados foram Dynomite
\cite{Dynomite}, Cassandra \cite{Lakshman2010}, Voldemort \cite{Voldemort} e
Riak \cite{Riak}. Todos eles usam basicamente a mesma arquitetura do Dynamo,
provendo gerenciamento de entrada e saída de nós no aglomerado, relógios vetor
para identificação e resolução de conflitos entre diferentes réplicas dos
objetos \cite{Lamport1978} e espalhamento consistente para o particionamento dos
objetos \cite{Karger1997a}.

O Dynomite foi descartado pois o projeto foi abandonado pela comunidade em um
estado ainda instável. O Cassandra por outro lado possui estabilidade e uma
comunidade bastante ativa, mas é mais complexo que os outros sistemas dado que
também implementa características de SGBDs orientados a colunas
\cite{Chang2006}. Dos dois sistemas restantes, o Riak foi escolhido por ser
implementado em Erlang, linguagem focada no desenvolvimento de sistemas
distribuídos, apresentando assim uma maior facilidade para o desenvolvimento do
modelo de consistência na linha do tempo. Um indício dessa facilidade é que o
riak\_kv, o módulo do Riak usado na implementação do novo modelo de
consistência, apresenta aproximadamente 20 mil linhas de código contra
aproximadamente 85 mil do Voldemort. Além disso, existe uma aplicação para
execução de testes usando Riak bastante completa (ver subseção
\ref{sec:aplicacao_de_execucao_dos_testes}). O Voldemort também possui aplicação
semelhante, mas ela oferece menos opções de configuração.

A implementação da consistência na linha do tempo é incompleta. É importante
para os experimentos a diferença entre leituras e escritas. Escritas podem ser
inserções, atualizações e remoções. Todas elas se comportam da mesma forma do
ponto de vista de tráfego local x remoto, por isso apenas atualizações são
implementadas de forma completa e eficiente. As atualizações distinguem a
localização de cada nó com relação aos centros de dados. Importante para a
análise do desempenho com relação à localidade, foi implementada a heurística do
PNUTS em que a réplica mestre migra para o centro de dados de onde vieram as
três últimas escritas. As inserções são ineficientes, ocorrendo sempre pela
mesma réplica, mesmo que em outro centro de dados. Isso foi feito para evitar
conflitos de inserção. Remoções não foram implementadas.

Além da implementação de consistência na linha do tempo, o riak\_kv foi alterado
para tratar corretamente os parâmetros extras necessários para a consistência na
linha do tempo recebidos através da interface HTTP. Outras alterações menores
dizem respeito a implementação de estatísticas sobre migrações.

Além do riak\_kv, outro módulo alterado foi o riak\_core. Quando o Riak recebe
uma requisição, ele descobre qual o nó responsável por tratá-la através do
algoritmo de espalhamento consistente, que se baseia no valor da chave do objeto
para tal. Originalmente, o Riak é pensado para ser implantado em um único centro
de dados, portanto o algoritmo não leva em consideração os centros de dados no
momento de decidir para qual das réplicas a requisição deve seguir. O Riak
Enterprise, uma versão paga do Riak, disponibiliza essa funcionalidade, mas esta
pesquisa precisava da versão de código aberto para ser viável. Dessa forma,
algumas modificações foram necessárias no riak\_core, módulo responsável pelo
roteamento das requisições, para que ele priorizasse nós do mesmo centro de
dados em que a requisição chegou. A implementação é muito simples e pouco
versátil, funcionando apenas para o cenário do estudo (dois centros de dados) e
baseada nos nomes dos nós para saber em que centro de dados cada um deles se
encontra.

%% ------------------------------------------------------------------------- %%
\subsection{Aplicação de execução dos testes}
\label{sec:aplicacao_de_execucao_dos_testes}

A aplicação de execução de testes usada é o Basho Bench \cite{Basho}, específica
para o Riak. Ela provê configurações para quantidade de clientes, distribuições
de acesso, proporção entre operações de leitura e escrita, entre outras. A
aplicação foi modificada, pois mais de uma instância dela é executada
simultaneamente nos experimentos, e portanto a geração dos acessos que
consideram localidade precisa ser coordenada entre elas. Além disso, foi
necessária a implementação de um script para a consolidação dos dados dos
obtidos pelas diversas instâncias do Basho Bench.

Outra aplicação de execução de testes considerada foi o YCSB \cite{Cooper2010}.
Apesar de possuir mais flexibilidade que o Basho Bench nas suas configurações,
ela não está preparada para acessar o Riak, acesso esse que precisaria ser
implementado. Além disso, ela também não oferece todas as funcionalidades
necessárias para os experimentos, que precisariam ser implementadas.

Nos experimentos, cada instância da aplicação de execução dos testes é dedicada
a um centro de dados. Essa configuração facilita a interpretação dos dados e
evita possíveis gargalos.

%% ------------------------------------------------------------------------- %%
\subsection{Imagem} \label{sec:imagem}

A imagem usada nesse estudo é um Debian GNU/Linux 6.0 (Squeeze) com kernel
2.6.32-5-amd64 baseado em uma imagem pré-configurada disponibilizada pelo
Grid5000. Além do conteúdo, essa imagem possui o Riak e o Basho Bench
modificados e algumas ferramentas de monitoração e análise de desempenho como
sysstat\footnote{\url{http://sebastien.godard.pagesperso-orange.fr/}},
bwm-ng\footnote{\url{http://www.gropp.org/?id=projects&sub=bwm-ng}} e
iperf\footnote{\url{http://iperf.sourceforge.net/}}. Existe uma única imagem, a
distinção entre nós executando instâncias do Riak ou do Basho Bench é feita
através dos scripts que gerenciam os experimentos
(\ref{sec:infraestrutura_dos_experimentos}).

%% ------------------------------------------------------------------------- %%
\subsection{Infraestrutura de execução e análise dos experimentos}
\label{sec:infraestrutura_de_execucao_e_analise_dos_experimentos}

Os experimentos são conduzidos através de dois conjuntos de scripts.  O primeiro
deles (cmb) se localiza no frontend do Grid5000 e é usado para reserva de nós,
instalação da imagem, gerenciamento do Riak, configuração e execução da
aplicação de testes e coleta de resultados. Os scripts são escritos em bash. O
segundo (cmb-local) se localiza na máquina do pesquisador e são utilizados para
manipulação e análise dos dados. Esses scripts são escritos em bash, Ruby e R.

%% ------------------------------------------------------------------------- %%
\section{Parâmetros fixados} \label{sec:parametros_fixados}

Os parâmetros levantados na lista inicial definida na seção
\ref{sec:lista_de_parametros} que não foram considerados fatores tiveram seus
valores fixados. Além deles, alguns fatores inicialmente considerados passaram a
parâmetros fixados após os experimentos intermediários (ver seção
\ref{sec:fatores_fixados_experimentalmente}).

Os parâmetros arbitrariamente fixados são:

\begin{itemize} \item Quantidade de centros de dados: 2. Com esse valor os
experimentos ficaram mais simples de executar e analisar devido a simetria do
sistema.

\item Quantidade de nós por centro de dados: Cada centro de dados tem o mesmo
tamanho (definido em função do tamanho do sistema) para garantir a simetria do
sistema.

\item Algoritmo de particionamento das chaves: O Riak já disponibiliza uma
implementação de espalhamento consistente. A única configuração feita é a
quantidade de partições utilizadas, que deve ser uma potência de 2 e a
documenação do Riak recomenda ao menos 10 por nó. Dessa forma o valor usado foi
512, que no maior tamanho do sistema considerado (16) garante as duas condições.

\item Algoritmo de detecção de falhas: Os experimentos sempre consideram
funcionamento correto dos nós, experimentos que apresentaram falha de algum nó
foram descartados e executados novamente.

\item Fator de replicação ($N$): 3. Esse é um valor que resulta em um balanço
razoável entre desempenho, disponibilidade e durabilidade em aplicações reais
\cite{DeCandia2007}.

\item Limiar de migração (para consistência na linha do tempo): 3. Valor usado
pelo PNUTS.

\item Interface de acesso: HTTP.

\item Nível de log: WARN. Alguns experimentos exploratórios mostraram perda de
desempenho quando o  nível de log estava em INFO. 

\item Topologia da rede: Os experimentos estavam limitados a topologia da rede
do aglomerado utilizado, consistindo dos 47 nós ligados a um switch.

%TODO: aqui ou outro lugar
%https://www.grid5000.fr/mediawiki/index.php/Sophia:Network#Sol_Cluster_.28Sun_X2200_M2.29

\item Banda disponível nos elementos intermediários (switches, roteadores, etc):
Limitada à oferecida pelo switch do aglomerado utilizado. Estudos exploratórios
mostraram que mesmo nos experimentos que mais demandavam banda não encontraram
gargalos devido a ela.

\item Latência da LAN: Limitada pelo aglomerado usado.  \end{itemize}

%TODO: qual é a latência?

%% ------------------------------------------------------------------------- %%
\section{Fatores fixados experimentalmente}
\label{sec:fatores_fixados_experimentalmente}

Quatro estudos experimentais foram executados para fixar os fatores. Com exceção
de um estudo, todos usaram projetos de experimentos fatoriais, cujo conceito
está explicado na subseção \ref{sec:projeto_de_experimentos_fatoriais}. O
mecanismo de armazenamento não usou experimentos fatoriais e está na subseção.
Os outros estudos usaram experimentos fatoriais e foram feitos para definir a
influência dos fatores relacionados a quantidade de nós do sistema, quantidade
de objetos e seus tamanhos, rede e carga de trabalho.
%TODO: Conteúdo das seções

Em alguns dos estudos foi possível notar que determinado fator afeta o
desempenho significativamente, mas mesmo assim ele foi fixado. Isso aconteceu
pois os experimentos finais não devem usar muitos fatores, fato comentado em
\cite{Jain1991} e sugerido para o pesquisdaro por Jean-Marc Vincent, pesquisador
visitante no IME com experiência em análise de desempenho experimental. Dado
isso, deu-se prioridade para fatores relacionados à rede e à carga de trabalho,
foco desta pesquisa. Fatores influentes que fixados foram incluídos na lista des
ameaças à validade (seção \ref{sec:ameacas_a_validade}).

Mas existem situações em que fixar um fator que aparece como influente não
necessariamente implica em grande ameaça à validade. Experimentos fatoriais
mostram a influência relativa de cada fator e cada interação entre fatores.
Nesse tipo de análise, o total de todas as influências relativas deve ser sempre
100\%. Por isso, mesmo que todos os fatores influenciem pouco o resultado, um ou
mais vão aparecer nos experimentos fatoriais com influência alta. Assim, também
foram calculados os CVs para cada resultado de forma a estimar qual a
importância daquele conjunto de fatores e interações como um todo.

Os experimentos descritos nesta seção usam percentis dos tempos de resposta das
requisições ao invés de médias. As requisições deste estudo são divididas entre
locais, da ordem de poucos milisegundos, e remotas, da ordem de centenas de
milisegundos. Dessa forma, as requisições remotas dominam a média já que são em
geral duas ordens de grandeza maiores que as locais. Por isso os estudos fazem
análises distintas para cada tipo de requisição, usando percentis: percentis
baixos representam requisiçõesl ocais e percentis altos representam requisições
remotas. Também é feita a distinção entre escritas e leituras dada a diferença
de natureza dessas operações.

% ------------------------------------------------------------------------- %%
\subsection{Projeto de experimentos fatoriais}
\label{sec:projeto_de_experimentos_fatoriais}

%TODO: talvez citar o outro livro de performance
Existem dois tipos principais de projetos de experimentos fatoriais: completos e
2\textsuperscript{k} \cite{Jain1991}.

Um projeto de experimento fatorial completo é constituído por todas as
combinações possíveis de todos os níveis de todos os fatores. Assim, a
quantidade total de experimentos é dada por:

$n = \prod_{i=1}^k{n_i}$,

onde k é o número de fatores e $n_i$ é a quantidade de níveis do
i$^{\textrm{\'esimo}}$ fator.

Esse tipo de projeto de experimento tem a vantagem de identificar com precisão a
influência de todos os fatores e suas interações no resultado. Mas quanto maior
a quantidade de fatores e de níveis em um estudo experimental, maior a
quantidade de recursos necessários para sua execução-- tempo e energia, por
exemplo. Normalmente os fatores não influenciam igualmente os resultados. Pelo
contrário, é comum ter alguns poucos fatores responsáveis pela maioria dos
resultados.

Assim, é comum utilizar projetos de experimentos fatoriais 2\textsuperscript{k}
para fazer a triagem dos fatores, identificando quais são os mais influentes.
Feito isso, executa-se os experimentos finais a partir de um projeto de
experimento fatorial completo apenas com esses fatores mais influentes.

Em um projeto de experimentos fatoriais 2\textsuperscript{k}, escolhe-se apenas
dois níveis para cada fator inicialmente selecionado, normalmente os níveis
mínimo e máximo. A seguir, executa-se os experimentos para todas as
2\textsuperscript{k} combinações possíveis entre os fatores.

O desempenho pode ser expresso por um modelo de regressão não-linear da forma:

$y = q_0 + q_Ax_A + q_Bx_B + q_Cx_C + ... + q_{AB}x_Ax_B + q_{AC}x_Ax_C +
q_{BC}x_Bx_C... + q_{ABC}x_Ax_Bx_C + ...$,

onde $y$ é o desempenho medido, $q_0$, $q_A$, $q_B$, etc são os coeficentes do
modelo, $x_A$, $x_B$, $x_C$, etc representam respectivamente os níveis dos
fatores A, B, C, etc. Os termos compostos pela multiplicação de dois ou mais
fatores representam as interações entre os fatores em questão. Fatores e as
interações entre fatores são chamados efeitos.

Feito o modelo, define-se uma relação entre os níveis de cada fator como sendo 1
ou -1. Por exemplo, para a relação leitura/escrita, pode-se definir que 2:1 vale
1 e a 10:1 vale -1. Assim, fazendo a substituição dos níveis e do desempenho
medido para cada experimento, tem-se um sistema de 2\textsuperscript{k} equações
e 2\textsuperscript{k} variáveis (os coeficientes).

Com os coeficientes pode-se calcular a variação total de y ou soma total dos
quadrados a partir da equação:

$STQ = SQA + SQB + SQC + ... + SQAB + SQAC + SQBC + ... + SQABC + ...$,

onde cada $SQX$ é dado por:

$SQX = 2^kq_X$

Cada $SQX$ é a porção da variação total explicada pelo efeito X. A partir disso
é possível finalmente calcular a fração da variação explicada pelo efeito X por:

$FSQX = SQX / STQ$

Comparando todos os $FSQX$s é possível descobrir quais os efeitos (e
consequentemente quais fatores) mais influenciam os resultados dos experimentos.

%% ------------------------------------------------------------------------- %%
\subsection{Mecanismo de armazenamento} \label{sec:mecanismo_de_armazenamento}

Esse é o único fator que não usou experimentos fatoriais para ser fixado -- na
época em que foi feito o pesquisador ainda não conhecia o projeto desse tipo de
experimento. Apesar disso, os resultados obtidos são suficientes para apoiar a
decisão de fixar esse fator.

Os experimentos feitos para o mecanismo de armazenamento mostraram diferenças
consideráveis no desempenho do Riak em aglomerados diferentes. Considerando que
os experimentos são limitados por E/S (e não por CPU) e que não havia gargalo de
rede, decidiu-se verificar o desempenho dos discos em cada aglomerado. Pela
especificação do hardware dos aglomerados é possível notar que os discos são de
tipos diferentes. Assim, como esperado, essa diferença no desempenho dos discos
apareceu nos resultados. Para medição do desempenho, os experimentos usaram o
hdparm para acesso sequencial e o
seeker\footnote{url{http://www.linuxinsight.com/how\_fast\_is\_your\_disk.html}}
para acesso aleatório. Os resultados podem ser vistos na Tabela
\ref{tab:comparacao_de_discos_entre_aglomerados}.

\begin{table}[!h] \begin{center} \begin{tabular}{|c|c|c|c|c|c|} \hline
Aglomerado & Tipo & Tamanho & Acesso sequencial (MB/s) & Acesso aleatório
(seeks/s) & Acesso aleatório (tempo de resposta em ms) \\ \hline sol & & & 59,8
& 78 & 12,7 \\ \hline suno & & & 242,7 & 131 & 7,6 \\ \hline griffon & & & 73,9
& 56 & 17,6 \\ \hline parapluie & & & 103,9 & 77 & 13,0 \\ \hline \end{tabular}
\caption{Comparação de desempenho dos discos entre aglomerados}
\label{tab:comparacao_de_desempenho_dos_discos_entre_aglomerados} \end{center}
\end{table}

Além  do tipo de disco, um outro fator a considerar era o cache de disco. Em
sistemas Linux, todo a memória livre é automaticamente usada como cache de
disco. Dado isso, existiam três opções para a execução dos experimentos com
relação ao mecanismo de armazenamento, considerando que um tamanho do banco de
dados podia ser escolhido de forma a manter todos os dados em memória:

\begin{enumerate} \item Dados em disco e cache limpo no início dos testes: O
cenário seria mais real, mas mais difícil de analisar pois os efeitos do disco e
da memória sobre o desempenho do sistema se misturariam. Além disso, o efeito do
preenchimento do cache seria um complicador extra, dado que durante um teste uma
dada chave acessada mais de uma vez seria servida do disco a primeira vez e da
memória nas seguintes.

\item Dados em cache no início dos testes: O disco seria predominantemente usado
apenas para escritas e as leituras seriam servidas a partir do cache.

\item Dados em memória: O Riak pode ser configurado para funcionar como um banco
de dados em memória, eliminando definitivamente o efeito do disco.
\end{enumerate}

A terceira opção foi a escolhida. Realizar os experimentos com banco de dados em
memória deve gerar resultados mais precisos e fáceis de ser interpretados por
descartar a influência de desempenho do disco. A princípio os resultados podem
parecer menos realistas e aplicáveis, mas na prática eles são tão limitados
quanto o uso de disco, já que nesse caso os resultados são influenciados pelo
tipo de disco e pela relação entre o tamanho do banco de dados e a memória
livre. Um exemplo pode ser visto na comparação de suno com parapluie, em que o
primeiro possui discos com taxas de acesso acima do 1Gb/s da rede -- o gargalo
em caso seria a rede, em outro o disco. Além disso, efeitos do cache de disco
tornariam os resultados ainda mais particulares e difíceis de ser generalizados.
Dessa forma, ao se usar banco de dados em memória elimina-se os efeitos das
interações entre rede, disco e cache de disco e a análise pode ser focada apenas
na rede.

%% ------------------------------------------------------------------------- %%
\subsection{Quantidade de nós do sistema e aglomerado}
\label{sec:quantidade_de_nos_do_sistema_e_aglomerado}

Além da quantidade de nós do sistema, estes experimentos fatoriais incluíram
dois fatores não considerados na lista de fatores inicial: quantidade de
instâncias da aplicação de testes e quantidade de threads em cada instância da
aplicação de testes. Esses dois fatores não haviam sido considerados
inicialmente pois o passo de levantamento dos parâmetros acontece antes da
seleção da técnica de avaliação. Assim, eles só foram considerados após medição
ser definida como técnica de avaliação para este estudo, o que fez surgir a
necessidade de dimensionar não só sistema mas também a aplicação de execução dos
testes.

Este estudo usou modo lt\_rec, localidade de 50\% e latência de rede de 100ms.
Esses valores foram escolhidos pois através deles obtém-se uma quantidade
balanceada de leituras e escritas locais e remotas. O resultado do estudo pode
ser visto na Tabela \ref{tab:estudo_para_quantidade_de_nos_do_sistema}.

\begin{table}[!h] \begin{center} \begin{tabular}{|c|c|c|c|c|c|c|c|c|} \hline
Operação & Percentil & N & A & T & NA & NT & AT & NAT\\ \hline leitura & 10 & 30
& 18 & 22 & 10 & 8 & 7 & 4 \\ \hline leitura & 90 & 65 & 13 & 15 & 3 & 4 & 0 & 0
\\ \hline escrita & 10 & 96 & 2 & 1 & 0 & 0 & 0 & 0 \\ \hline escrita & 90 & 65
& 15 & 13 & 3 & 3 & 0 & 0 \\ \hline \end{tabular} \caption{Estudo para
quantidade de nós do sistema. N representa a quantidade de nós do sistema, A
representa a quantidade de instâncias da aplicação de execução de testes e T
representa a quantidade de threads usadas em cada instânca da aplicação de
execução de testes.} \label{tab:estudo_para_quantidade_de_nos_do_sistema}
\end{center} \end{table}

Na maioria dos casos, o tamanho do sistema tem a maior influência nos resultados
e a quantidade de instâncias da aplicação de execução de testes e a quantidade
de threads não são desprezíveis, ainda mais ao se considerar as interações entre
elas. Como comentado no início desta seção, mesmo sendo influentes, alguns
fatores foram fixados para manter a quantidade de fatores finais baixa. Esse foi
o caso dos três fatores desse estudo. Nesse caso, a opção foi por manter o maior
tamanho de sistema possível, evitando gargalos de rede ao máximoe não
sobrecarregando o sistema.  Por isso, a opção foi por um sistema com 16 nós
(maior valor), 4 instâncias da aplicação de testes (maior valor) e a 32 threads
em cada uma (menor valor).  Esses valores resultam na configuração ``mais
leve'', fato confirmado através da observação dos FDAs.

Uma outra opção a esses valores seria o uso de 32 nós do sistema e 8 instâncias
da aplicação de testes, resultando em um total de 40 nós. Isso não foi feito por
questões operacionais. Ao definir que o sistema usaria memória como mecanismo de
armazenamento, a escolha do aglomerado passou a ser menos relevante, dado que
todos os aglomerados oferecem nós com capacidade de processamento (CPU)
razoável, ao menos 4GB de memória e placas de rede de 1Gb/s.  O aglomerado sol
foi escolhido predominantemente por questões operacionais -- ele é um dos
maiores aglomerados disponíveis no Grid5000 (47 nós) e tem baixa concorrência
com outros pesquisadores pela reserva de nós. Mas mesmo assim, é muito comum
alguns poucos nós já estarem reservados por outros pesquisadores, além de alguns
nós apresentarem falhas no momento da implantação da imagem. Esse último
problema levou o pesquisador a sempre reservar alguns nós além dos necessários
para garantir a quantidade mínima de nós para executar os experimentos. Dessa
forma, experimentos que precisassem de 40 nós seriam mais difíceis de ser
executados.

%% ------------------------------------------------------------------------- %%
\subsection{Quantidade de objetos armazenados e tamanho dos objetos armazenados}
\label{sec:quantidade_de_objetos_armazenados_e_tamanho_dos_objetos_armazenados}

Os experimentos fatoriais relacionados ao tamanho do banco de dados também
consideraram o atraso de rede como fator. O atraso de rede foi usado como uma
simplificação da WAN, dessa forma foi possível comparar a importância relativa
entre esses fatores e a rede.

Este estudo usou modo lt\_rec e localidade de 50\%.  Esses valores foram
escolhidos pois através deles obtém-se uma quantidade balanceada de leituras e
escritas locais e remotas. O resultado do estudo pode ser visto na Tabela
\ref{tab:estudo_para_quantidade_e_tamanho_dos_objetos_armazenados}.

\begin{table}[!h] \begin{center} \begin{tabular}{|c|c|c|c|c|c|c|c|c|} \hline
Operação & Percentil & Q & T & L & QT & QL & TL & QTL\\ \hline leitura & 10 & 0
& 100 & 0 & 0 & 0 & 0 & 0 \\ \hline leitura & 90 & 0 & 0 & 100 & 0 & 0 & 0 & 0
\\ \hline escrita & 10 & 0 & 100 & 0 & 0 & 0 & 0 & 0 \\ \hline escrita & 90 & 0
& 0 & 100 & 0 & 0 & 0 & 0 \\ \hline \end{tabular} \caption{Estudo para
quantidade e tamanho dos objetos armazenados. Q representa a quantidade de
objetos armazenados, T representa o tamanho dos objetos armazenados e L
representa a latência.}
\label{tab:estudo_para_quantidade_e_tamanho_dos_objetos_armazenados}.
\end{center} \end{table}

É possível perceber que a quantidade de objetos não afeta o desempenho do
sistema. Como o tempo de aquecimento depende da quantidade de objetos
armazenados, quanto menor essa quantidade mais rápido os experimentos são
executados. Por outro lado, optou-se por um número não tão baixo de forma a
evitar um excesso de conflitos. O valor escolhido foi 128000 objetos, o que
resulta em uma média de 8000 objetos por nó (os experimentos usam 16 nós), baixo
para um sistema de produção mas suficiente para este estudo.

O tamanho dos objetos não afeta o desempenho das requisições remotas. E apesar
desse fator aparecer com 100\% de influência nas requisições locais, o CV dessas
requisições foi de 19\% para leituras e 16\% para escritas.  Além disso, o foco
desta pesquisa está no comportamento do sistema na WAN, onde as requisições são
duas ordens de grandeza maiores. Dada a necessidade de eliminar fatores do
experimento, decidiu-se fixar o tamanho dos objetos. O valor escolhido foi 500
bytes. Essa escolha está baseada em um estudo dos sistemas de caching
distribuído no Facebook que relata que 90\% dos valores de praticamente todos os
sistemas está abaixo de 500 bytes.

%TODO: comentar conflitos, resultados são estranhos confl : 5 44 44 1 2 5 1   |
%CV =  0.6548619 TODO: citar Workload Analysis of a Large-Scale Key-Value Store

%% ------------------------------------------------------------------------- %%
\subsection{Fatores de rede} \label{sec:fatores_de_rede}

Um estudo preliminar foi feito para verificar o tamanho dos buffers de leitura e
escrita para verificar as recomendações que dizem que os buffers devem ser o
dobro do BDP. A principal motivação de checar esse fato é que alguns
experimentos com iperf mostraram ganhos de desempenho para buffers até quatro
vezes maiores que o BDP.  . Esse é um tipo de cenário que coloca bastante
pressão nos buffers.

Este estudo usou modo lt\_rec e localidade de 50\%. Esses valores foram
escolhidos pois através deles obtém-se uma quantidade balanceada de leituras e
escritas locais e remotas. Para a rede, o estudo usou latências de 100ms e
300ms, variação de latência de 50\% e taxas de pacotes fora do ordem de 0\% e
5\%. A alta variabilidade e os pacotes fora de ordem criam um cenário que
pressiona os buffers de envio e recepção. O resultado do estudo pode ser visto
na Tabela \ref{tab:estudo_para_tamanho_dos_buffers_de_envio_e_recepcao}.

\begin{table}[!h] \begin{center} \begin{tabular}{|c|c|c|c|c|c|c|c|c|} \hline
Operação & Percentil & L & O & B & LO & LB & OB & LOB\\ \hline leitura & 10 & 92
& 0 & 3 & 0 & 0 & 2 & 3\\ \hline leitura & 90 & 98 & 0 & 1 & 0 & 0 & 0 & 0\\
\hline escrita & 10 & 87 & 11 & 0 & 1 & 1 & 0 & 0\\ \hline escrita & 90 & 99 & 0
& 0 & 0 & 0 & 0 & 0\\ \hline \end{tabular} \caption{Estudo para tamanho dos
buffers de envio e recepção. L representa a latência, R representa a taxa de
pacotes fora de ordem e B representa o tamanho dos buffers.}
\label{tab:estudo_para_tamanho_dos_buffers_de_envio_e_recepcao}.  \end{center}
\end{table}

Como o tamanho dos buffers não afetou o desempenho, a opção foi por
configurá-los como o dobro do BDP, seguindo as recomendações.

Feito isso, os experimentos para rede foram executados. A taxa de pacotes
corrompidos não foi considerada neste estudo pois experimentos preliminares
fizeram com que nós do Riak falhasesm por problemas de comunicação. Como nenhuma
referência indicando que a taxa de pacotes corrompidos é um fator fundamental em
WANs, a opção foi ignorar esse fator.

O resultado do estudo pode ser visto na Tabela
\ref{tab:estudo_para_fatores_de_rede} (devido ao grande números de colunas da
tabela apenas colunas com ao menos um valor diferente de 0 são apresentadas).

\begin{table}[!h] \begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} \hline Operação & Percentil \\
\hline leitura & 10 \\ \hline leitura & 90 \\ \hline escrita & 10 \\ \hline
escrita & 90 \\ \hline \end{tabular} \caption{Estudo para fatores de rede. L
representa a latência, V representa a variação da latência, P representa as taxa
de perdas, D representa a taxa de pacotes duplicados, O representa a taxa de
pacotes fora de ordem e C representa o algoritmo de congestionamento.}
\label{tab:estudo_para_fatores_de_rede}.  \end{center} \end{table}

%TODO: decidir se faz uma tabela pra cada ordem de efeitos (3a e talvez 4a ordem
%precisem de 2 tabelas) ou se só usa colunas != 0 (2 tabelas)

É possivel perceber que a latência, a variação da latência, a taxa de perdas e
as interações entre elas são os fatores que mais afetam o desempenho do sistema.
Assim, os níveis escolhidos para esses três fatores nos experimentos são:

\begin{itemize} \item Latência: 0, 100, 200, 300

\item Variação da latência: 50\%. Apesar de afetar o desempenho, a variação foi
fixada dado que grandes variações de latência em WANs são comuns. Além disso,
dos 3 fatores, esse é o que menos influencia, mesmo com os experimentos usando
variações bem diferentes (1\% e 50\%).

\item Taxa de perdas: 0, 0,05\% e 1\%. O primeiro valor representa a situação
ideal, o segundo uma taxa relativamente baixa e o terceito uma taxa alta.
\end{itemize}

Níveis nulos de latência, variação da latência e taxa de perdas equivalem a ter
todo o sistema operando em uma rede local. Os resultados obtidos para esses
casos devem ser usados como auxílio na interpretação dos resultados, mas não
devem ser considerados na análise final dado que sistemas geo-replicados, por
definição, não operam nessas condições.

As taxas de duplicação e de pacotes fora de ordem foram fixadas em 0. O
algoritmo de congestionamento foi fixado como ``cubic'', pois esse é o padrão no
Linux utilizado nos experimentos.

Apesar de a taxa de pacotes fora de ordem ser
fixada, a ocorrência de alguns pacotes fora
de ordem é possível dada a variação da latência. O emulador de WAN foi configurado para aplicar uma
correlação na variação da latência usando distribuição normal. Com isso, a
probabilidade de grandes diferenças de latência entre pacotes consecutivos é 
baixa, diminuindo assim a probabilidade de pacotes fora de ordem.

%% ------------------------------------------------------------------------- %%
\subsection{Fatores de carga de trabalho}
\label{sec:fatores_de_carga_de_trabalho}

Os experimentos para fatores de carga de trabalho também
consideraram o atraso de rede como fator. O atraso de rede foi usado como uma
simplificação da WAN, dessa forma foi possível comparar a importância relativa
entre esses fatores e a rede.

Como os modos possuem comportamentos diferentes para requisições locais e
remotas, os experimentos foram executados para cada modo. O resultado para
requisições locais apresentaram CVs em torno de 0,02 para todos os modos. Isso
indica que requisições locais não sofrem influência de nenhum dos fatores. Já
requisições remotas apresentaram CV de aproximadamente 0,5 e 100\% de influência
do atraso para ind2, tl\_qqer e tl\_rec (ind1 não tem requisições remotas).

A análise da relação leitura/escrita e localidade são feitas pela média do tempo
de resposta do total de requisições e não pelos percentis. Isso
porque o primeiro fator diz respeito à composição entre leituras e escritas e o
segundo à composição entre requisições locais e remotas. Por exemplo, com
localidade 0,5 percebe-se que o percentil 70 representa requisições remotas,
enquanto com localidade 0,9 o mesmo percentil representa requisições locais. Se
a análise fosse feita por percentis, essa informação se perderia e localidade
nunca teria influência (como pode ser observado pelos baixos CVs). Dado issom, o resultado do estudo pode ser visto na Tabela
\ref{tab:estudo_para_fatores_de_carga_de_trabalho}

\begin{table}[!h] \begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline Modo & R & X & P & L & RX & RP & RL & XP & XL & PL & RXP
& RXL & RPL & XPL & RXPL\\
\hline ind1 & 19 & 12 & 2 & 31 & 0 & 3 & 2 & 4 & 6 & 6 & 4 & 0 & 0 & 8 & 1\\
\hline ind2 & 50 & 0 & 0 & 39 & 0 & 0 & 11 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
\hline lt\_qqer & 25 & 30 & 0 & 19 & 9 & 0 & 6 & 0 & 8 & 0 & 0 & 3 & 0 & 0 & 0\\
\hline lt\_rec & 0 & 53 & 0 & 34 & 0 & 0 & 0 & 0 & 13 & 0 & 0 & 0 & 0 & 0 & 0\\
\hline
\end{tabular}
\caption{Estudo para fatores de carga de trabalho para ind1. R representa a
relação leitura/escrita, X representa a localidade, P representa a popularidade
e L representa a latência de rede.}
\label{tab:estudo_para_fatores_de_carga_de_trabalho}.
\end{center}
\end{table}

Apesar de alguns modos aparentemente sofrerem impacto considerável da relação
leitura/escrita, há indícios de que esse impacto na verdade é consequência da relação
entre requisições locais e remotas. O modo ind1 tem tanto leituras quanto
escritas locais e a relação leitura/escrita e suas interações com outros fatores impacta pouco
esse modo. No modo lt\_rec tanto leituras quanto escritas são locais ou remotas
dependendo da localidade e a relação leitura/escrita não impacta esse modo. O
modo ind2 tem todas as leituras locais e todas as escritas remotas. Assim, ao 
mudar a relação leitura/escrita está mudando a relação entre requisições locais
e remotas. Como esperado, esse modo é impactado pela relação leitura/escrita.
O mesmo vale para lt\_qqer que tem todas as leituras locais e escritas
dependendo da localidade. Esse modo também sofre impacto da relação
leitura/escrita.

Caso o mecanismo de armazenamento fosse disco ao invés de memória, a relação
leitura/escrita provavelmente sofreria impacto de fato. Isso porque escritas
implicariam no tempo de disco enquanto leituras poderiam ser mais rápidas no
geral pelo fato de uma parte delas serem servidas a partir do cache de disco.
Mas como não é esse o caso, a diferença relevante é a relação entre requisições
locais e remotas. Dessa forma, a opção foi fixar o fator em 2:1.

Como esperado, localidade e latência impactam os modos em geral. Uma observação
é o fato de incusive ind1 ser afetada por latência. Isso provavelmente vem do
fato de mecanismos de replicação e correção de leitura serem afetados. Dado
isso, os níveis para localidade usados são 0,5 e 0,9.

Percebe-se em todos os casos impacto praticamente nulo de popularidade. Talvez
em uma situação em que o sistema recebesse uma carga maior, como no caso de um
teste de stress, esse fator passaria a ser relevante. Como não é o caso, ele foi
fixado no nível ``uniforme''.

%% ------------------------------------------------------------------------- %%
\section{Ameaças à validade} \label{sec:ameacas_a_validade}

O controle da latência para caracterizar uma WAN é uma simplificação. Existem
outros fatores em uma WAN que afetam o desempenho de um sistema executando nela,
como limitações na largura da banda disponível, congestionamento, perda de
pacotes e explosões de tráfego. Os resultados obtidos podem ser diferentes em
uma WAN real, sujeita a esses fatores.

O Riak usa uma arquitetura muito semelhante à descrita no artigo sobre o Dynamo.
Com isso, os modelos de consistência usados nos experimentos podem apresentar
outros resultados em sistemas que usem outras arquiteturas, embora a
implementação de cada modelo de consistência é bastante isolada dos outros
componentes da arquitetura.

Por limitação de tempo e recursos algumas variáveis que podem alterar os
resultados desse trabalho foram desconsideradas ou fixadas. Esse é o caso de
todas as variáveis de controle e constantes, que poderiam ser trabalhadas como
variáveis independentes. Com isso, os resultados dos experimentos podem ser
diferentes caso sejam usados, por exemplo, um fator de replicação ou uma
quantidade de centros de dados diferentes. Em particular, testes de
escalabilidade serão realizados para entender a influência do tamanho do sistema
nos resultados.

Os experimentos consideram que todos os nós sempre operam sem falhas. Os
resultados de experimentos com o sistema operando em algum modo de falha (desde
a falha de um nó até de um centro de dados inteiro) devem ser diferentes dos
obtidos nesse estudo.
