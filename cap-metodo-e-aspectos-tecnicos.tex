%% ------------------------------------------------------------------------- %%
\chapter{Método e Aspectos Técnicos} \label{cap:metodo_e_aspectos_tecnicos}

O método usado neste trabalho se baseia na abordagem para análise de desempenho
proposta por Jain em \cite{Jain1991}. As atividades envolvidas neste estudo se
dividiram em três etapas. A primeira contemplou a definição do que seria
realizado e dos aspectos técnicos de implementação dos experimentos e está
descrita neste capítulo. A segunda etapa teve por objetivo definir parâmetros e
selecionar fatores e níveis e está descrita no capítulo
\ref{cap:parametros_e_fatores}. A terceira etapa compreendeu a execução dos
experimentos seguida da análise dos resultados e se encontra no capítulo
\ref{cap:analise_dos_resultados}.

TODO: seções

%% ------------------------------------------------------------------------- %%
\section{Definição do estudo} \label{sec:definicao_do_estudo}

TODO: intro + seções

%% ------------------------------------------------------------------------- %%
\subsection{Nomenclatura} \label{sec:nomenclatura}

A literatura sobre experimentos apresenta alguns termos importantes para a
comunicação de objetivos, procedimentos e resultados. Termos usados
frequentemente neste e nos próximos capítulos são:

\begin{itemize} \item Variáveis de resposta: Resultados de um experimento
(variáveis dependentes). Como este estudo é uma análise de desempenho, as
variáveis de resposta são as métricas, que são os critérios usados em uma
comparação de desempenho.

\item Parâmetros: Características do sistema, do ambiente de operação e da carga
de trabalho que afetam o desempenho do sistema.

\item Fatores: Parâmetros que são variados nos experimentos (variáveis
independentes) e cujo efeito no desempenho é analisado. Parâmetros que não são
fatores possuem um único valor em todos os experimentos (variáveis fixas e
constantes).

\item Níveis: Valores assumidos pelos fatores nos experimentos.

\item Interação entre fatores: Se o desempenho sempre varia da mesma forma ao se
alterar o nível de um determinado fator, não há interação entre esse e os demais
fatores. Mas se a variação do desempenho acontece depende do nível de outro(s)
fator(es), existe interação entre eles.

\item Ordem de uma interação entre fatores: A quantidade de fatores envolvidos
na interação -- por exemplo, uma interação de terceira ordem é uma interação
entre três fatores.

\item Projeto dos experimentos: Especificação do número de experimentos e das
combinações de fatores e níveis usados.

\end{itemize}

%% ------------------------------------------------------------------------- %%
\subsection{Metas do estudo} \label{sec:metas_do_estudo}

O objetivo deste estudo é comparar o desempenho da consistência em momento
indeterminado com o da consistência na linha do tempo em um sistema de
armazenamento distribuído geo-replicado. Essa situação é modelada como um único
sistema distribuído entre centros de dados ligados por uma WAN. Nesse cenário,
uma requisição local é aquela atendida no mesmo centro de dados em que chega e
possui baixo tempo de resposta (da ordem de poucos milissegundos). Já uma
requisição remota é aquela que chega em um determinado centro de dados e é
encaminhada para ser atendida em outro, e normalmente possui tempo de resposta
alto (da ordem de dezenas ou centenas de milissegundos). O modelo usado neste
estudo possibilita diferentes combinações entre requisições locais e remotas
dependendo do modelo de consistência usado e da sua configuração (ver subseção
\ref{sec:modo}).

% Definição do TCP, no summary do TCP em Stevens. TODO: citar
Para entender a dinâmica do sistema geo-replicado é necessário entender as
características da rede sobre a qual ele opera. Este estudo considera um sistema
operando sobre TCP/IP, pilha de protocolos comumente utilizada nesses sistemas.
O protocolo IP provê os mecanismos de endereçamento e roteamento. O protocolo
TCP provê conexão ponto-a-ponto confiável, reconhecendo os dados recebidos,
enviando-os novamente caso o reconhecimento não seja recebido dentro de um
determinado período de tempo, reordenando pacotes recebidos fora de ordem,
descartando pacotes duplicados, verificando pacotes corrompidos e provendo
controle de fluxo.

Por limitações de escopo e recurso, este estudo analisa o sistema apenas do
ponto de vista do desempenho. Isso significa que o estudo não considera outros
atributos de qualidade como disponibilidade e manutenibilidade. Assim, o escopo
está limitado à operação normal do sistema, não levando em consideração
condições excepcionais, como falha de nós ou sobrecarga do sistema. Essas e
outras condições podem ser estudadas em trabalho futuros (ver seção
\ref{sec:trabalhos_futuros}).

%% ------------------------------------------------------------------------- %%
\subsection{Métricas} \label{sec:metricas}

A principal métrica usada como base de comparação do desempenho dos modelos de
consistência é o tempo de resposta das requisições (em s). Quanto menor o tempo
de resposta, melhor é o desempenho de um modelo de consistência. Como
requisições locais e remotas apresentam tempos de resposta bem diferentes,
percentis são usados em vez da média na maior parte das análises.

Além do tempo de resposta, outras métricas observadas foram vazão (em
operações/s), quantidade de migrações e quantidade de conflitos (ambas dadas
pela porcentagem com relação ao total de operações do experimento). Vazão não é
considerada uma meta principal pois os clientes apresentam uma taxa de
requisição fixada nos experimentos, de forma a diminuir possíveis influências de
sobrecarga do sistema. A quantidade de migrações, exclusiva da consistência na
linha do tempo, oferece uma visão da dinâmica de um sistema que use esse modelo
de consistência. A quantidade de conflitos proporciona uma noção da frequência
com que cliente leem valores desatualizados. Uma diferença entre conflitos nos
dois tipos de consistência é que na linha do tempo eles são causados apenas por
atualizações que ainda não chegaram a todas as réplicas, portanto serão
automaticamente resolvidos. Já na consistência em momento indeterminado, eles
podem ser mais graves, dado que esse modelo permite atualizações concorrentes
divergentes.

%% ------------------------------------------------------------------------- %%
\subsection{Técnica de avaliação} \label{sec:tecnica_de_avaliacao}

Existem três técnicas comumente usadas na análise de desempenho de sistemas:
simulação, modelagem analítica e medição \cite{Jain1991}. É muito difícil criar
simuladores ou modelos que levem em consideração a interação entre todos os
parâmetros que afetam o desempenho de um modelo de consistência: as diferentes
cargas de trabalho (incluindo questões de localidade), as características da
rede, os algoritmos de resolução de conflitos, etc. Assim, a adoção de simulação
ou modelagem analítica sacrificaria o realismo e a precisão deste estudo. Daí a
escolha de medição, pela qual é possível analisar o comportamento de um sistema
de armazenamento que represente o resultado da interação de vários dos fatores
que afetam o desempenho de um modelo de consistência.

Dada a técnica de avaliação selecionada, este estudo precisava de um sistema
implementado para que as medições fossem feitas. Mas considerando que o objetivo
era comparar dois modelos de consistência e não sistemas que os implementem, os
experimentos foram planejados e executados de forma a isolar tanto quanto
possível questões específicas do sistema. Além disso, era importante testar os
modelos em diferentes condições da rede, portanto os experimentos usaram uma WAN
emulada. Os nós do sistema foram agrupados como se estivessem em centros de
dados diferentes, ligados pela WAN emulada. A carga de trabalho foi executada
por um benchmark que simulava clientes localizados em cada um dos centros de
dados. Cada experimento era definido por um modelo de consistência e sua
configuração, uma configuração de rede (latência, perda de pacotes, etc) e uma
carga de trabalho (relação leitura/escrita, localidade, etc). Detalhes sobre o
sistema e o benchmark usados e o ambiente em que eles operaram nos experimentos
estão na seção \ref{sec:aspectos_tecnicos}.

%% ------------------------------------------------------------------------- %%
\section{Aspectos técnicos} \label{sec:aspectos_tecnicos}

Após definir medição como técnica de avaliação de desempenho neste estudo, o
passo seguinte foi o planejamento técnico dos experimentos. Esse planejamento
envolveu predominantemente atividades de programação e administração de
sistemas, como implementação da consistência na linha do tempo e preparação de
scripts para a execução dos experimentos.

O sistema de armazenamento usado como objeto dos experimentos é descrito na
subseção \ref{sec:sistema_de_armazenamento}. O ambiente dos experimentos é
definido pela plataforma escolhida para executá-los, descrita na subseção
\ref{sec:ambiente}.  A forma como a WAN é emulada é descrita na subseção
\ref{sec:rede}. A carga sobre o sistema é definida pelo benchmark, descrito na
subseção \ref{sec:benchmark}.

%% ------------------------------------------------------------------------- %%
\subsection{Sistema de armazenamento} \label{sec:sistema_de_armazenamento}

Uma abordagem para a comparação dos modelos de consistência seria o uso de um
sistema de armazenamento já existente que implementasse os dois modelos de
consistência, mas tal sistema não foi encontrado. A partir disso, uma outra
abordagem seria o uso de sistemas diferentes, cada um implementando um modelo de
consistência. Apesar de existirem experimentos que usam essa abordagem
\cite{Cooper2008,Stonebraker2007,Pavlo2009}, dois problemas foram identificados.
O primeiro é que o desempenho de cada sistema é afetado por parâmetros
particulares do sistema que não o modelo de consistência, como a tecnologia
utilizada, detalhes de configuração, entre outros. No caso de uso de mais de um
sistema, esses fatores, pouco importantes para este estudo, precisariam ser
levados em conta. O segundo problema é que apesar de existirem sistemas de
armazenamento de software livre / código aberto que implementam consistência em
momento indeterminado, não foram encontrados sistemas que implementassem
consistência na linha do tempo.

Assim, decidiu-se usar um único sistema para os experimentos. Uma opção para tal
era implementar um sistema de armazenamento distribuído específico para os
experimentos. O problema dessa abordagem é que esse tipo de sistema é bastante
complexo, já que precisa prover funcionalidades como controle de entrada e saída
dos nós, algoritmos de particionamento, etc. Desenvolver todas essas
funcionalidades inviabilizaria este trabalho devido ao alto custo em tempo para
implementação.

Para evitar a implementação completa de um sistema de armazenamento, algumas
opções de software livre / código aberto foram analisadas. A seleção das opções
foi feita considerando modelos de consistência, estabilidade da solução e
simplicidade de desenvolvimento. Como não foram encontrados sistemas de
armazenamento de software livre / código aberto que implementem consistência na
linha do tempo, as soluções avaliadas foram aquelas que implementam consistência
em momento indeterminado. Os sistemas encontrados foram Dynomite
\cite{Dynomite}, Cassandra \cite{Lakshman2010}, Voldemort \cite{Voldemort} e
Riak \cite{Riak}. Todos eles usam basicamente a mesma arquitetura do Dynamo,
provendo gerenciamento de entrada e saída de nós no aglomerado, relógios vetor
para identificação e resolução de conflitos entre diferentes réplicas dos
objetos \cite{Lamport1978} e espalhamento consistente para o particionamento dos
objetos \cite{Karger1997a}.

O Dynomite foi descartado pois o projeto foi abandonado pela comunidade em um
estado ainda instável. O Cassandra por outro lado possui estabilidade e uma
comunidade bastante ativa, mas é mais complexo que os outros sistemas dado que
também implementa características de SGBDs orientados a colunas
\cite{Chang2006}. Dos dois sistemas restantes, o Riak foi escolhido por ser
implementado em Erlang, linguagem focada no desenvolvimento de sistemas
distribuídos, apresentando assim maior facilidade para o desenvolvimento do
modelo de consistência na linha do tempo. Um indício dessa facilidade é que o
riak\_kv, o módulo do Riak usado na implementação do novo modelo de
consistência, apresenta aproximadamente 20 mil linhas de código contra
aproximadamente 85 mil do Voldemort. Além disso, existe um benchmark para o Riak
bastante completa (ver subseção \ref{sec:benchmark}). O Voldemort também possui
benchmark semelhante, mas ele oferece menos opções de configuração.

%% ------------------------------------------------------------------------- %%
\subsubsection{Implementação da consistência na linha do tempo no Riak}

A implementação da consistência na linha do tempo é incompleta. Para os
experimentos, a distinção entre leituras e escritas era importante. Mas a
distinção entre os tipo de escrita (inserção, atualização ou remoção) não era
muito importante dado que os tipos se comportam da mesma forma do ponto de vista
de tráfego local x remoto. Assim, apenas atualizações foram implementadas de
forma completa e eficiente, distinguindo a localização de cada nó com relação
aos centros de dados. As inserções para uma dada chave ocorrem sempre pela mesma
réplica, mesmo que isso signifique encaminhar para outro centro de dados uma
requisição que em princípio poderia ser tratada localmente. Esse procedimento
eliminou a necessidade de implementação de um mecanismo para evitar conflitos de
inserção. Apesar de inserções serem ineficientes, isso não afetou os resultados,
dado que os experimentos só usam inserção na carga do sistema (ver subseção
\ref{sec:fluxo_de_trabalho_dos_experimentos}). Remoções não foram implementadas.

O PNUTS conta com uma heurística simples mas importante para o desempenho da
consistência na linha do tempo, que explora a localidade de requisições: a
réplica mestre migra para o centro de dados de onde vieram as últimas escritas.
Essa heurística foi implementada no Riak.

%% ------------------------------------------------------------------------- %%
\subsubsection{Outras modificações implementadas no Riak}

Além da implementação de consistência na linha do tempo, o riak\_kv foi alterado
para tratar corretamente os parâmetros extras necessários para a consistência na
linha do tempo recebidos através da interface HTTP. Outras alterações menores
dizem respeito a implementação de estatísticas sobre migrações.

Além do riak\_kv, outro módulo alterado foi o riak\_core. Quando o Riak recebe
uma requisição, ele descobre qual o nó responsável por tratá-la através do
algoritmo de espalhamento consistente, que se baseia no valor da chave do
objeto. O Riak foi projetado para ser implantado em um único centro de
dados\footnote{A versão Enterprise do Riak implementa replicação entre centros
de dados, mas é paga.}, portanto o algoritmo não leva em consideração os centros
de dados no momento de decidir para qual das réplicas a requisição deve seguir.
Dessa forma, algumas modificações foram necessárias no riak\_core, módulo
responsável pelo roteamento das requisições, para que ele priorizasse nós do
mesmo centro de dados em que a requisição chegou. A implementação é muito
simples e pouco versátil, funcionando apenas para o cenário do estudo (dois
centros de dados -- ver seção \ref{sec:parametros_fixados}) e baseada nos nomes
dos nós para saber em qual centro de dados cada um deles se encontra.

%% ------------------------------------------------------------------------- %%
\subsection{Benchmark} \label{sec:benchmark}

% artigos que usam o termo benchmark, em itálico
% http://sbrc2012.dcc.ufmg.br/app/pdfs/p-05/wcga/WCGA-ST3-2.pdf
% http://www2.dbd.puc-rio.br/pergamum/tesesabertas/0521501_10_cap_04.pdf

O benchmark usado foi o Basho Bench \cite{Basho}, específico para o Riak. Ele
provê configurações para quantidade de clientes concorrentes (threads), relação
leitura/escrita, popularidade dos objetos acessados, entre outras. O benchmark
foi modificado, pois mais de uma instância dele foi executado simultaneamente
nos experimentos. Além de evitar gargalos no benchmark, isso era importante para
a implementação de localidade nos experimentos. Além disso, foi necessária a
implementação de um script para a consolidação dos dados obtidos pelas diversas
instâncias do Basho Bench.

Outro benchmark considerado foi o YCSB \cite{Cooper2010}.  Apesar de possuir
mais flexibilidade que o Basho Bench nas suas configurações, ele não estava
preparado para acessar o Riak, acesso esse que precisaria ser implementado. Além
disso, ele também não oferecia muitas das funcionalidades necessárias para os
experimentos, que precisariam ser implementadas.

%% ------------------------------------------------------------------------- %%
\subsection{Ambiente} \label{sec:ambiente}

Os experimentos foram executados no
Grid5000\footnote{\url{http://www.grid5000.fr/}}, uma plataforma para criação,
execução e monitoramento de experimentos de sistemas paralelos e distribuídos. A
plataforma possui mais de 5000 cores distribuídos em 9 sítios na França e um no
Brasil.

Outras plataformas como o OpenCirrus\footnote{\url{http://opencirrus.org/}},
PlanetLab\footnote{\url{http://www.planet-lab.org/}} também foram consideradas,
mas foram descartadas por uma questão de conveniência, já que o autor deste
trabalho utilizou o Grid5000 em dois estágios de mestrado de respectivamente
quatro meses e um mês pelo INRIA na França. A experiência no ambiente adquirida
nesse período foi reutilizada neste trabalho, tornando o projeto e a execução
dos experimentos mais produtivos. O Amazon Web Services (AWS)
\footnote{\url{http://aws.amazon.com/}} também foi considerado, mas foi
descartado por se tratar de ambiente virtualizado, o que dificultaria a
interpretação dos resultados e a reprodutibilidade dos experimentos.

A operação no Grid5000 se dá através do acesso ssh ao frontend de cada sítio.
Nele o usuário encontra seu diretório home, onde ele armazena seus scripts e
dados dos experimentos, e tem acesso a ferramentas específicas da
infraestrutura. Como o Grid5000 é compartilhado por diversos pesquisadores, ele
oferece um conjunto de ferramentas (OAR\footnote{\url{http://oar.imag.fr/}}) e
regras para que um pesquisador reserve nós exclusivamente para ele por um
determinado período de tempo. Além dos nós, é possível reservar IPs para compor
sub-redes, recurso utilizado nos experimentos (ver subseção \ref{sec:rede}).
Outra ferramenta bastante utilizada é o
kadeploy\footnote{\url{http://kadeploy.imag.fr/}}, responsável pela implantação
de imagens nos nós reservados pelo usuário.

%% ------------------------------------------------------------------------- %%
\subsubsection{Imagem}

A imagem usada nos experimentos é um Debian GNU/Linux 6.0 (Squeeze) com kernel
2.6.32-5-amd64 baseado em uma imagem pré-configurada disponibilizada pelo
Grid5000 (squeeze-x64-base). Além do conteúdo da imagem base, a imagem usada nos
experimentos possui o Riak e o Basho Bench modificados e algumas ferramentas de
monitoração e análise de desempenho como
sysstat\footnote{\url{http://sebastien.godard.pagesperso-orange.fr/}},
bwm-ng\footnote{\url{http://www.gropp.org/?id=projects&sub=bwm-ng}} e
iperf\footnote{\url{http://iperf.sourceforge.net/}}. Uma única imagem foi usada,
a distinção entre nós executando instâncias do Riak ou do Basho Bench foi feita
através dos scripts que gerenciam os experimentos.

%% ------------------------------------------------------------------------- %%
\subsection{Rede} \label{sec:rede}

Os sítios do Grid5000 são conectados por redes de alta velocidade. Suas redes
apresentam latências da ordem de centenas de nanosegundos entre nós de um mesmo
aglomerado e da ordem de 20 ms entre sítios, e portanto não caracterizam uma
WAN. De qualquer forma, mesmo que caracterizassem, é necessário ter controle
sobre esses valores para medir o desempenho do sistema em diferentes condições
de rede e possibilitar a reprodutibilidade dos experimentos.

Por isso, os experimentos usam a ferramenta traffic control (tc). Ela é usada na
manipulação das filas de saída de pacotes de uma interface de rede, priorizando
um determinado tipo de tráfego, por exemplo. Mais especificamente para emulação
da WAN, o
netem\footnote{\url{http://www.linuxfoundation.org/collaborate/workgroups/networking/}}
foi usado. Ele provê funcionalidade para inserção de latência de rede, variação
da latência, perda de pacotes, pacotes duplicados, corrompidos e/ou fora de
ordem.  Existem outras ferramentas como o
dummynet\footnote{\url{http://info.iet.unipi.it/~luigi/dummynet/}} e o
NISTNet\footnote{\url{http://snad.ncsl.nist.gov/itg/nistnet/}}, mas elas foram
desconsideradas dado que o netem já vem integrado ao tc e satisfazia os
requisitos funcionais dos experimentos.

Existem recomendações sobre otimizações de sistemas Linux para quando se
comunicam usando WANs. Durante os experimentos, sempre que os parâmetros da WAN
foram alterados, um script para ajuste da pilha TCP foi usado. A principal
otimização desse script era ajustar os tamanhos dos buffers de transmissão e
recepção ao BDP (para mais detalhes, ver seção \ref{sec:fatores_de_rede}).

\subsubsection{Centros de dados}

Os experimentos foram planejados para usar dois centros de dados simulados (ver
seção \ref{sec:parametros_fixados}). Para simular os centros de dados, os nós
que compunham o sistema eram divididos em dois conjuntos CD1 e CD2, cada um
representando um centro de dados. Além dos nós, duas sub-redes SR1 e SR2 eram
reservadas. Cada nó de CD1 recebia, além de seu IP da rede do Grid5000, um IP de
SR1, o mesmo valendo para CD2 e SR2.

Sistemas Linux usam o arquivo /etc/hosts como fonte primária para resolução de
nomes, consultando um DNS apenas quando não encontram um nome definido ali (o
que é a situação mais comum). Todos os nós no Grid5000 possuem um nome
registrado no DNS que aponta para o seu IP da rede do Grid5000. Nos
experimentos, dois arquivos hosts1 e hosts2 eram criados e substituíam o
/etc/hosts dos nós de CD1 e CD2 respectivamente. O conteúdo de hosts1 eram os
nomes dos nós de CD1 sendo resolvidos para os IPs de SR1, o mesmo valendo entre
hosts2 e SR2. Com isso, os nós de CD1 resolviam os nomes dos nós de CD2 para os
IPs de SR2 e vice-versa. O resultado dessa configuraçõa é que todas as
requisições que saíam de um centro de dados para o outro usavam o IP da sub-rede
de destino, enquanto as requisições para o mesmo centro de dados usavam o IP da
rede do Grid5000.

A partir dessa configuração foi possível adicionar um filtro baseado em
sub-redes ao tc de modo que as características de WAN eram aplicadas às
requisições que saíam para o outro centro de dados, enquanto as requisições para
o mesmo centro de dados saíam inalteradas.

%TODO: dummynet: Marta Carbone and Luigi Rizzo, Dummynet Revisited, ACM SIGCOMM
%Computer Communication Review, 40(2) pg.12-20, March 2010


%% ------------------------------------------------------------------------- %%
\subsection{Fluxo de trabalho dos experimentos}
\label{sec:fluxo_de_trabalho_dos_experimentos}

O fluxo de trabalho dos experimentos foi dado por dois conjuntos de scripts.  O
primeiro (cmb) se localizava no frontend do Grid5000 e era usado para reserva de
nós, instalação da imagem, gerenciamento do sistema de armazenamento,
configuração e execução do benchmark e coleta dos resultados. Os scripts foram
escritos em bash. O segundo conjunto (cmb-local) foi usado na análise dos dados
e se localizava no computador do autor. Esses scripts foram escritos em bash,
Ruby e R.

Uma vez feita a reserva de nós, a execução de um estudo consistia dos seguintes
passos:

\begin{tikzpicture}[node distance = 2cm, auto]

\node [block] (deploy) {Implantação da imagem nos nós};

\node [block, below of=deploy] (srvs) {Configuração dos nós};

\path [line] (deploy) -- (srvs);
%\item Configuração do Riak
%
%\item Inicialização do Riak
%
%\item Configuração do benchmark
%
%\item Carga do sistema -- incluindo aquecimento
%
%\item Configuração da WAN emulada -- incluindo ajuste da pilha TCP/IP
%
%\item Configuração do benchmark
%
%\item Execução do benchmark
%
%\item Finalização do Riak

\end{tikzpicture}

Cada um desses passos corresponde a um script. Os passos estavam definidos em um
outro script (run-all), responsável pelo fluxo de trabalho.

% Comentar sanity checks
