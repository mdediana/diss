%% ------------------------------------------------------------------------- %%
\chapter{Discussão e Experimentos} \label{cap:discussao_e_experimentos}

Vários sistemas distribuídos geograficamente, como DNS, redes P2P e aplicações
como as disponibilizadas por Google, Amazon e Facebook usam consistência em
momento indeterminado para atingir alta escalabilidade. Esse modelo de
consistência tornou-se particularmente popular em sistemas de armazenamento
usados por sistemas geo-replicados após a publicação do artigo sobre o Dynamo
\cite{DeCandia2007}. A difusão de princípios arquiteturais como o CAP
popularizou ainda mais a consistência em momento indeterminado (ver subseção
\ref{sec:consistencia_disponibilidade_tolerancia_a_particionamento}).

Consistência mais rígida implica em disponibilidade ou tolerância a
particionamento diminuídos. Como em sistemas geo-replicados não é possível abrir
mão de tolerância a particionamento, ao optar por consistência mais rígida a
única opção restante é aceitar uma menor disponibilidade. Além das aplicações
que necessitam de níveis mais altos de consistência, aplicações que tolerem
níveis mais baixos de disponibilidade também podem se beneficiar de um modelo de
consistência mais rígido devido a uma manutenibilidade mais alta, que facilite o
projeto e desenvolvimento tanto do sistema de armazenamento quanto da aplicação.
A consistência na linha do tempo pode oferecer um balanço interessante entre
manutenibilidade, desempenho e disponibilidade nesses casos.

Este trabalho é um estudo exploratório que consiste em uma análise experimental
do desempenho da consistência em momento indeterminado e da consistência na
linha do tempo de acordo com diferentes cargas de trabalho e características de
rede como latência, perda e duplicação de pacotes, entre outros. Por limitações
de escopo, este trabalho não analisa a relação entre esses modelos de
consistência e disponibilidade, manutenibilidade ou qualquer outro atributo de
qualidade influenciado por eles.

Existem três técnicas comumente usadas na análise de desempenho de sistemas:
simulação, modelagem analítica e experimentação \cite{Jain1991}. É muito difícil
criar simuladores ou modelos que levem em consideração a interação entre todos
os fatores que afetam o desempenho de um modelo de consistência: as diferentes
cargas de trabalho (incluindo questões de localidade), as características da
rede, os algoritmos de resolução de conflitos, etc. Assim, a adoção de simulação
ou modelagem analítica sacrificaria o realismo e a precisão deste trabalho. Daí
a escolha de experimentação, pela qual é possível analisar o comportamento de um
sistema de armazenamento que represente o resultado da interação de vários dos
fatores que afetam o desempenho de um modelo de consistência.

Esse estudo consiste em rodar o sistema dividido entre dois centros de dados
simulados. Os centros de dados são ligados por uma WAN emulada. A carga de
trabalho é executada por uma aplicação de testes simulando clientes localizados
em cada um dos centros de dados. Cada experimento consiste em uma configuração
de rede (latência, perda de pacotes, etc) e uma carga de trabalho (relação
leitura/escrita, localidade, etc).

A seção \ref{sec:aspectos_tecnicos} descreve aspectos técnicos do sistema como o
ambiente dos experimentos, a forma como a rede é emulada e o sistema de
armazenamento no qual os diferentes modelos de consistência são implementados. A
seção \ref{sec:projeto_dos_experimentos} trata do projeto dos experimentos.


%TODO: Simulação x emulação

%% ------------------------------------------------------------------------- %%
\section{Aspectos técnicos} \label{sec:aspectos_tecnicos}

O desempenho de um sistema é resultado do ambiente em que ele opera, das suas
características (incluindo arquitetura) e da carga de trabalho apresentada. O
ambiente dos experimentos é definido pela plataforma escolhida para executá-los,
descrita na subseção \ref{sec:ambiente}. A forma como a WAN é emulada é descrita
na subseção \ref{sec:rede}. O sistema de armazenamento usado como objeto de
testes, no qual são implementados os modelos de consistência, é descrito na
subseção \ref{sec:sistema_de_armazenamento}.  A carga sobre o sistema é definida
pela aplicação de execução dos testes, descrita na subseção
\ref{sec:aplicacao_de_execucao_dos_testes}. O sistema de armazenamento, a
aplicação de testes e ferramentas de monitoração e análise de desempenho compõem
a imagem, descrita na seção \ref{sec:imagem}. Por fim, a descrição da
infraestrutura de gerenciamento dos experimentos se encontra na seção
\ref{sec:infraestrutura_dos_experimentos}.

%% ------------------------------------------------------------------------- %%
\subsection{Ambiente} \label{sec:ambiente}

Os experimentos foram executados no
Grid5000\footnote{\url{http://www.grid5000.fr/}}, uma plataforma para criação,
execução e monitoramento de experimentos de sistemas paralelos e distribuídos. A
plataforma possui mais de 5000 cores distribuídos em 9 sítios na França e um no
Brasil.

Outras plataformas como o OpenCirrus\footnote{\url{http://opencirrus.org/}} e
PlanetLab\footnote{\url{http://www.planet-lab.org/}} também foram consideradas,
mas foram descartadas por uma questão de conveniência, já que o autor deste
trabalho utilizou o Grid5000 em dois estágios de mestrado de respectivamente
quatro meses e um mês pelo INRIA na França. A experiência no ambiente adquirida
nesse período pode ser reutilizada neste trabalho, tornando o projeto e a
execução dos experimentos mais produtivos. O Amazon Web Services (AWS)
\footnote{\url{http://aws.amazon.com/}} também foi considerado, mas foi
descartado por não ser possível ter controle sobre as características de rede
entre os centros de dados, o que dificultaria a a interpretação dos resultados e
a reprodutibilidade dos experimentos.

A operação no Grid5000 se dá através do acesso ssh a uma máquina particular de
cada sítio, o frontend. No frontend, o usuário encontra seu diretório home, onde
ele pode guardar seus scripts e dados dos experimentos, além de usar as
ferramentas do Grid5000.

Dentre as ferramentas mais importantes estão as de reserva e gerenciamento de
máquinas. O Grid5000 é uma infraestrutura compartilhada por diversos
pesquisadores. Portanto, ele oferece um conjunto de ferramentas
(OAR\footnote{\url{http://oar.imag.fr/}}) e regras para que um pesquisador
reserve nós exclusivamente para ele por um determinado período de tempo.
Além de nós, é possível reservar IPs para compor sub-redes, recurso
também utilizado nessa pesquisa (ver \ref{sec:rede}). Outra ferramenta bastante
utilizada é o kadeploy\footnote{\url{http://kadeploy.imag.fr/}}, responsável
pela implantação de imagens nos nós reservados pelo usuário.

%TODO: Falar do HW

%% ------------------------------------------------------------------------- %%
\subsection{Rede} \label{sec:rede}

Os sítios do Grid5000 são conectados por redes de alta velocidade. Suas redes
apresentam latências da ordem de dezenas de nanosegundos entre nós de um mesmo
aglomerado e da ordem de 20 ms entre sítios, e portanto não caracterizam uma
WAN. De qualquer forma, mesmo que caracterizassem, é importante para esse
estudo ter controle sobre esses valores para poder testar os sistema em
diferentes configurações e possibilitar sua reprodutibilidade.

Assim, os experimentos implementam uma latência artificial para simular uma WAN
entre os centros de dados usando a ferramenta traffic control (tc). Essa
ferramenta possibilita a manipulação das filas de saída de pacotes de uma dada
interface de rede do sistema operacional. Mais especificamente para emulação de
WANs, é possível usar o
netem\footnote{\url{http://www.linuxfoundation.org/collaborate/workgroups/networking/}},
que provê funcionalidade para emulação de latência de rede incluindo variação da
latência, perda de pacotes, pacotes duplicados, corrompidos e/ou fora de ordem.
Existem outras ferramentas como o
dummynet\footnote{\url{http://info.iet.unipi.it/~luigi/dummynet/}} e o
NISTNet\footnote{\url{http://snad.ncsl.nist.gov/itg/nistnet/}}, mas elas foram
desconsideradas dado que o netem já vem integrado ao tc e satisfaz os requisitos
funcionais desse estudo.

\subsubsection{Simulação de centros de dados}
\label{sec:simulacao_de_centros_de_dados}

Os nós que compõem o sistema são divididos em dois conjuntos CD1 e CD2,
cada um representando um centro de dados. Além dos nós, são reservadas
duas sub-redes SR1 e SR2. IPs de SR1 e SR2 são alocados para cada cada nó
de CD1 e CD2, respectivamente. Ao final, cada nó possui dois IPs, o seu IP
da rede do Grid5000 e um IP de uma das sub-redes.

Todos os nós no Grid5000 possuem um nome registrado no DNS que aponta
para o seu IP da rede do Grid5000. Nos experimentos dois arquivos /etc/hosts são
criados, um por centro de dados. Um deles é colocado em todos os nós de
CD1 e o outro em todos os nós de CD2. A partir dessa configuração, os
nós do CD1 resolvem os nomes dos nós do CD2 para os IPs de SR2 e
vice-versa. Como o /etc/hosts tem prioridade sobre o DNS na resolução de nomes,
todas as requisições que saem de um centro de dados para o outro usam o IP
daquela sub-rede, enquanto as requisições para o mesmo centro de dados usam o IP
da rede do Grid5000.

A partir dessa distinção é possível adicionar um filtro baseado em sub-redes ao
tc de modo que as características de WAN são aplicadas às requisições que saem
para o outro centro de dados, enquanto as requisições para a mesma sub-rede saem
inalteradas.

%TODO: dummynet: Marta Carbone and Luigi Rizzo, Dummynet Revisited, ACM SIGCOMM
%Computer Communication Review, 40(2) pg.12-20, March 2010

%% ------------------------------------------------------------------------- %%
\subsection{Sistema de armazenamento} \label{sec:sistema_de_armazenamento}

Uma abordagem para a comparação dos modelos de consistência é o uso de um
sistema de armazenamento já existente que implemente os dois modelos de
consistência, mas tal sistema não foi encontrado. A partir disso, uma segunda
abordagem possível é o uso de sistemas diferentes, cada um implementando um
modelo de consistência. Apesar de existirem experimentos que usam essa abordagem
\cite{Cooper2008,Stonebraker2007,Pavlo2009}, dois problemas foram identificados.
O primeiro é que o desempenho de cada sistema pode ser afetado por fatores
particulares do sistema que não o modelo de consistência, como a tecnologia
utilizada, protocolo de acesso, detalhes de configuração, entre outros. O
segundo é apesar de existirem sistemas de armazenamento de software livre /
código aberto que implementem consistência em momento indeterminado, não foram
encontrados sistemas que implementem consistência na linha do tempo.

A partir disso, os experimentos vão usar um único sistema, isolando assim o
modelo de consistência como único fator de influência no seu desempenho. Uma
opção para tal é implementar um sistema de armazenamento distribuído específico
para os experimentos. O problema dessa abordagem é que esse tipo de sistema é
bastante complexo, já que precisa prover funcionalidades como controle de
entrada e saída dos nós, algoritmos de particionamento, etc. Desenvolver todas
essas funcionalidades inviabilizaria este trabalho devido ao alto custo em tempo
para implementação.

Para evitar a implementação completa de um sistema de armazenamento, algumas
opções de software livre / código aberto foram analisadas. A seleção das opções
foi feita considerando modelos de consistência, estabilidade da solução e
simplicidade de desenvolvimento. Como não foram encontrados sistemas de
armazenamento de software livre / código aberto que implementem consistência na
linha do tempo, as soluções avaliadas foram aquelas que implementam consistência
em momento indeterminado. Os sistemas encontrados foram Dynomite
\cite{Dynomite}, Cassandra \cite{Lakshman2010}, Voldemort \cite{Voldemort} e
Riak \cite{Riak}. Todos eles usam basicamente a mesma arquitetura do Dynamo,
provendo gerenciamento de entrada e saída de nós no aglomerado, relógios vetor
para identificação e resolução de conflitos entre diferentes réplicas dos
objetos \cite{Lamport1978} e espalhamento consistente para o particionamento dos
objetos \cite{Karger1997a}.

O Dynomite foi descartado pois o projeto foi abandonado pela comunidade em um
estado ainda instável. O Cassandra por outro lado possui estabilidade e uma
comunidade bastante ativa, mas é mais complexo que os outros sistemas dado que
também implementa características de SGBDs orientados a colunas
\cite{Chang2006}. Dos dois sistemas restantes, o Riak foi escolhido por ser
implementado em Erlang, linguagem focada no desenvolvimento de sistemas
distribuídos, apresentando assim uma maior facilidade para o desenvolvimento do
modelo de consistência na linha do tempo. Um indício dessa facilidade é que o
riak\_kv, o módulo do Riak usado na implementação do novo modelo de
consistência, apresenta aproximadamente 20 mil linhas de código contra
aproximadamente 85 mil do Voldemort. Além disso, existe uma aplicação para
execução de testes usando Riak bastante completa (ver subseção
\ref{sec:aplicacao_de_execucao_dos_testes}). O Voldemort também possui aplicação
semelhante, mas ela oferece menos opções de configuração. Mas nenhum desses é
motivo suficientemente forte para descartar totalmente o Voldemort, portanto ele
se mantém como uma opção para os experimentos caso alguma dificuldade específica
com o Riak seja encontrada.

Além da implementação de consistência na linha do tempo, o riak\_kv foi alterado
para tratar corretamente alguns parâmetros extras usados pela consistência na
linha do tempo recebidos através da interface HTTP. Outras alterações menores
dizem respeito a implementação de estatísticas sobre migrações.

Além do riak\_kv, outro módulo alterado foi o riak\_core. Quando o Riak recebe
uma requisição, ele descobre qual o nó responsável por tratá-la através do 
algoritmo de espalhamento consistente, que se baseia no valor da chave do objeto
para tal. Originalmente, o Riak é pensado para ser
implantado em um único centro de dados, portanto o algoritmo não leva em
consideração os centros de dados no momento de decidir para qual das réplicas a
requisição deve seguir. O Riak Enterprise, uma versão paga do Riak,
disponibiliza essa funcionalidade, mas essa pesquisa precisava da versão de
código aberto para ser viável. Dessa forma algumas modificações foram
necessárias no riak\_core, módulo que é responsável pelo roteamento das
requisições, para que ele priorizasse nós do mesmo centro de dados em que a
requisição chegou. A implementação é muito simples e pouco versátil, funcionando
apenas para o cenário da pesquisa (dois centros de dados) e baseada nos
nomes dos nós para saber em que centro de dados cada um deles se encontra.

%% ------------------------------------------------------------------------- %%
\subsection{Aplicação de execução dos testes}
\label{sec:aplicacao_de_execucao_dos_testes}

A aplicação de execução de testes usada é o Basho Bench \cite{Basho}, específica
para o Riak. Ela provê configurações para quantidade de clientes, distribuições
de acesso, proporção entre operações de leitura e escrita, entre outras. A
aplicação foi modificada, pois mais de uma instância dela é executada
simultaneamente nos experimentos, e portanto a geração dos acessos que
consideram localidade precisa ser coordenada entre elas. Além disso, foi
necessária a implementação de um script para a consolidação dos dados dos
obtidos pelas diversas instâncias do Basho Bench.

Outra aplicação de execução de testes considerada foi o YCSB \cite{Cooper2010}.
Apesar de possuir mais flexibilidade que o Basho Bench nas suas configurações,
ela não está preparada para acessar o Riak, acesso esse que precisaria ser
implementado. Além disso, ela também não oferece todas as funcionalidades
necessárias para os experimentos, que precisariam ser implementadas.

Nos experimentos, cada instância da aplicação de execução dos testes é dedicada
a um centro de dados. Essa configuração facilita a interpretação dos dados e
evita possíveis gargalos.

%% ------------------------------------------------------------------------- %%
\subsection{Imagem} \label{sec:imagem}

A imagem usada nesse estudo é um Debian Squeeze baseado em uma imagem
pré-configurada disponibilizada pelo Grid5000. Além do conteúdo, essa imagem
possui o Riak e o Basho Bench modificados e algumas ferramentas de monitoração e
análise de desempenho como
sysstat\footnote{\url{http://sebastien.godard.pagesperso-orange.fr/}},
bwm-ng\footnote{\url{http://www.gropp.org/?id=projects&sub=bwm-ng}} e
iperf\footnote{\url{http://iperf.sourceforge.net/}}. Existe uma única imagem, a
distinção entre nós executando instâncias do Riak ou do Basho Bench é
feita através dos scripts que gerenciam os experimentos
(\ref{sec:infraestrutura_dos_experimentos}).

%% ------------------------------------------------------------------------- %%
\subsection{Infraestrutura dos experimentos}
\label{sec:infraestrutura_dos_experimentos}

Os experimentos são basicamente conduzidos através de dois conjuntos de scripts.
O primeiro (cmb) deles se localiza no frontend do Grid5000, e é usado para
reserva de nós, instalação da imagem, gerenciamento do Riak, configuração
e execução da aplicação de testes e coleta de resultados. Os scripts são
escritos em bash.  O segundo (cmb-local) se localiza na máquina do pesquisador e
são utilizados para manipulação e análise dos dados. Esses scripts são escritos
em bash, Ruby e R.

%% ------------------------------------------------------------------------- %%
\section{Projeto dos experimentos} \label{sec:projeto_dos_experimentos}

A definição dos experimentos é feita de acordo com as variáveis a serem
trabalhadas. As variáveis dependentes, que medem a influência sobre o fenômeno
investigado, são descritas na subseção \ref{sec:variaveis_dependentes}. As
variáveis independentes, que são as variáveis modificadas para criar os
diferentes cenários dos experimentos, são descritas na subseção
\ref{sec:variaveis_independentes}. As variáveis de controle e as constantes são
os valores fixos, convencionados ou naturais usados nos experimentos e são
descritas na subseção \ref{sec:variaveis_de_controle_e_constantes}. Além das
variáveis, também são apresentadas nesta seção as ameaças à validade dos
experimentos na subseção \ref{sec:ameacas_a_validade}, os resultados parciais
obtidos até o momento na subseção \ref{sec:resultados_parciais} e o formato a
ser usado na apresentação dos resultados dos experimentos na subseção
\ref{sec:apresentacao_dos_resultados}.

%% ------------------------------------------------------------------------- %%
\subsection{Variáveis dependentes} \label{sec:variaveis_dependentes}

As duas principais variáveis dependentes a serem observadas e usadas como base
de comparação do desempenho dos modelos de consistência são vazão (medida em
operações/s) e tempo de resposta das requisições (medido em ms). Quanto maior a
vazão e menor o tempo de resposta, melhor o desempenho de um modelo de
consistência. Para uma dada carga de trabalho e latência de rede, a relação da
vazão e do tempo de resposta entre os modelos de consistência resulta no ganho
(ou perda) percentual de desempenho ao se optar por um ou outro modelo.

Os modelos de consistência e configurações que permitem conflitos entre réplicas
podem sofrer uma perda de desempenho devido à execução de algoritmos de detecção
e recuperação de conflitos. Por isso também serão medidos os conflitos expostos
para os clientes e as reparações de réplicas, ambas apresentadas como
porcentagens relativas ao total de requisições.

%% ------------------------------------------------------------------------- %%
\subsection{Variáveis independentes} \label{sec:variaveis_independentes}

As variáveis independentes foram escolhidas de forma a aproximar esse trabalho
dos ambientes de produção de sistemas web geo-replicados. Apesar disso, a lista
de variáveis independentes não é exaustiva (ver subseção
\ref{sec:ameacas_a_validade}) por limitações de escopo do trabalho e de
recursos. Além disso, existem limites de generalização já que aplicações
diferentes possuem requisitos específicos.

%% ------------------------------------------------------------------------- %%
\subsubsection{Modelos de consistência} \label{sec:modelos_de_consistencia}

Todas as configurações usam $N = 3$ e $W = 1$ (ver subseção
\ref{sec:variaveis_de_controle_e_constantes}).

Os modelos de consistência usados nos experimentos são\footnote{Consistência na
linha do tempo com leituras de versões específicas é um meio termo entre
leituras consistentes e leituras de qualquer versão, portanto não é considerada
nos experimentos.}:

\begin{itemize} \item Consistência em momento indeterminado (W=1, R=1), \item
consistência na linha do tempo com leituras consistentes, \item consistência na
linha do tempo com leituras de qualquer versão.  \end{itemize}

%% ------------------------------------------------------------------------- %%
\subsubsection{Latência da rede} \label{sec:latencia_da_rede}

O desempenho de um sistema é afetado pela rede sobre a qual ele opera. A
latência da rede entre centros de dados é o principal fator que justifica
otimizações que fazem uso de localidade. Uma WAN pode afetar o desempenho de um
sistema não só devido à latência, mas também devido a limitações na largura da
banda disponível, congestionamento, perda de pacotes, explosões de tráfego, etc.
Apesar dos outros fatores, esses experimentos adotam uma simplificação e usam
apenas a latência entre centros de dados para caracterizar uma WAN (ver subseção
\ref{sec:ameacas_a_validade}).

As latências de ida e volta médias usadas nos experimentos são baseadas nas
latências entre os centros de dados dos Amazon Web Services \cite{Sovran2011}.
Os centros de dados considerados são Califórnia (EUA -- Costa Oeste), Virginia
(EUA -- Costa Leste), Irlanda e Singapura. A menor latência observada foi 82 ms
entre os centros de dados dos EUA e a maior foi 277 ms entre Irlanda e
Singapura. A partir disso, os valores usados nos experimentos são:

\begin{itemize} \item 0 ms, \item 100 ms, \item 200 ms, \item 300 ms.
\end{itemize}

O uso da latência como 0 ms é o equivalente de ter todo o sistema operando em
uma rede local. Os resultados obtidos para esse caso devem ser usados como
auxílio na interpretação dos resultados com latências maiores, mas não devem ser
considerados nas análises finais dado que sistemas geo- replicados, por
definição, não operam nessas condições.

%% ------------------------------------------------------------------------- %%
\subsubsection{Distribuição de operações} \label{sec:distribuicao_de_operacoes}

Diferentes distribuições de escrita/leitura resultam em diferentes desempenhos.
Por exemplo, a consistência na linha do tempo pode apresentar desempenho mais
baixo em um cenário de escrita intensiva, pois a réplica mestre pode se tornar
um gargalo. Além disso, a probabilidade de haver conflitos entre réplicas
aumenta com o aumento da taxa de escritas em um sistema que usa consistência em
momento indeterminado, que pode sofrer um impacto no seu desempenho devido à
execução de seus algoritmos de resolução de conflitos. Por outro lado, um
sistema que usa consistência na linha do tempo não apresenta esse problema dado
que conflitos entre réplicas não são possíveis.

As distribuições de operações usadas nos experimentos são:

\begin{itemize} \item Uniforme: 50\% de leituras e 50\% de escritas, \item
Leitura intensiva: 90\% de leituras, \item Escrita intensiva: 90\% de escritas.
\end{itemize}

%% ------------------------------------------------------------------------- %%
\subsubsection{Distribuição de alvos dos acessos}
\label{sec:distribuicao_de_alvos_dos_acessos}

Em muitas aplicações a popularidade dos objetos não é uniforme, alguns são mais
acessados do que outros. Um exemplo é uma loja virtual em que o interesse dos
clientes pelos produtos tende a obedecer uma lei de potência
\cite{Anderson2006}. A existência de objetos muito populares pode prejudicar o
desempenho de um modelo de consistência como a consistência na linha do tempo,
em que a réplica mestre pode se tornar um gargalo nas escritas.

As distribuições de alvos dos acessos usadas nos experimentos são:

\begin{itemize} \item Uniforme: Todos os objetos são acessados em média a mesma
quantidade de vezes, \item Concentrada: 10\% dos objetos recebem 90\% dos
acessos e os outros 90\% dos objetos recebem 10\% dos acessos.  \end{itemize}

A distribuição normal não é usada por simplicidade. Pelo teorema do limite
central, a medida em que o tamanho de uma amostra tende a infinito, a
distribuição normal e a uniforme se aproximam. Dado que a aplicação de execução
de testes já implementa a distribuição uniforme, não há a necessidade de
implementar a distribuição normal.

%% ------------------------------------------------------------------------- %%
\subsubsection{Localidade} \label{sec:localidade}

Cooper et al. notam um alto índice de localidade nos acessos aos objetos dos
sistemas no Yahoo! \cite{Cooper2008}. Em uma análise feita no período de uma
semana, foi observado que em média 85\% das escritas a determinado objeto vinham
do mesmo centro de dados. Isso acontece por exemplo em uma rede social, em que
os usuários costumam acessar a aplicação a partir da mesma localização
geográfica e possuem a maior parte de seus contatos na mesma localização
geográfica (usuários brasileiros tendem a acessar o sistema do Brasil e a
maioria de seus contatos é brasileira, por exemplo). Nesse caso, se os objetos
são particionados no sistema a partir da localização geográfica dos acessos mais
recentes é possível economizar um número considerável de requisições entre
centros de dados. A implementação do PNUTS usa esse fato para implementar uma
otimização de desempenho, movendo a réplica mestre para o centro de dados do
qual vieram os últimos 3 acessos ao objeto. Essa otimização também será
implementada no sistema de armazenamento usado nos experimentos.

Os perfis de acesso com relação à localidade usados nos experimentos são:

\begin{itemize} \item Uniforme: origem dos acessos para cada objeto distribuídos
igualmente entre centros de dados, \item Concentrada: 90\% dos acessos para cada
objeto originado em um centro de dados e os 10\% restantes originados em outros
centros de dados.  \end{itemize}

%% ------------------------------------------------------------------------- %%
\subsection{Variáveis de controle e constantes}
\label{sec:variaveis_de_controle_e_constantes}

As variáveis de controle e constantes usadas nos experimentos são:

\begin{itemize} \item Quantidade de centros de dados ($CD$): 2

\item Quantidade de instâncias da aplicação de execução dos testes ($I$): 1 por
centro de dados. Apesar de essa configuração dificultar o tratamento dos
resultados (que já estariam consolidados no caso de uma única instância ser
utilizada), ela é necessária para a simulação de clientes locais a cada um dos
centros de dados.

\item Tamanho do sistema ($T$): 100 nós. A principal limitação para o tamanho do
sistema é operacional. Os experimentos são realizados em um ambiente
compartilhado entre diversos pesquisadores (ver subseção \ref{sec:ambiente}),
que impõe limites da quantidade de nós que um pesquisador pode reservar em um
determinado período. Além disso, quanto maior a quantidade de nós solicitada,
menor a chance de a reserva ser bem sucedida. A experiência do autor deste
trabalho nesse ambiente diz que as chances de ter uma solicitação de reserva de
nós atendida cai bastante acima de 100 nós.

\item Quantidade de clientes ($C$): $T$. O valor é arbitrário, alguns testes
preliminares serão feitos para redefini-lo se necessário. O ideal é usar o valor
que resulte na maior vazão possível, o que implica que o sistema opera na sua
capacidade máxima.

\item Quantidade de nós por centro de dados: $T / CD$. Cada centro de dados tem
o mesmo tamanho.

\item Quantidade de clientes por centro de dados: $C / CD$. Os experimentos
consideram que a carga  em termos de quantidade de requisições é igualmente
distribuída entre os centros de dados.

\item Quantidade de partições do banco de dados: $16 * T$. A quantidade de
partições do sistema deve ser uma potência de 2 e a documentação do Riak
aconselha o uso de ao menos 10 partições por nó. Como a quantidade de partições
define o nível de concorrência em cada nó, os experimentos usam uma quantidade
de partições proporcional à quantidade de nós do aglomerado para manter o nível
de concorrência por nó constante.

\item Fator de replicação ($N$): 3. Esse é um valor que resulta em um balanço
razoável entre desempenho, disponibilidade e durabilidade em aplicações reais
\cite{DeCandia2007}.

\item Quantidade de réplicas para uma escrita bem sucedida ($W$): 1. Sistemas
reais preocupados com durabilidade usam $W >= 2$, já que no caso em que $W = 1$
o sistema pode perder uma escrita caso uma falha permanente ocorra após a
confirmação da escrita mas antes da sua replicação. Apesar disso, o valor 1 é
usado para uma melhor observação do efeito da localidade dos acessos, caso $W =
2$, algumas escritas precisariam ser propagadas para outros centros de dados
antes de serem consideradas bem sucedidas.

\item Quantidade de execuções para cada carga de trabalho e latência de rede: 3.
As execuções são repetidas para evitar possíveis variações nos resultados devido
a fenômenos temporários no ambiente de testes, como um problema de rede, por
exemplo.  \end{itemize}

%% ------------------------------------------------------------------------- %%
\subsection{Ameaças à validade} \label{sec:ameacas_a_validade}

O controle da latência para caracterizar uma WAN é uma simplificação. Existem
outros fatores em uma WAN que afetam o desempenho de um sistema executando nela,
como limitações na largura da banda disponível, congestionamento, perda de
pacotes e explosões de tráfego. Os resultados obtidos podem ser diferentes em
uma WAN real, sujeita a esses fatores.

O Riak usa uma arquitetura muito semelhante à descrita no artigo sobre o Dynamo.
Com isso, os modelos de consistência usados nos experimentos podem apresentar
outros resultados em sistemas que usem outras arquiteturas, embora a
implementação de cada modelo de consistência é bastante isolada dos outros
componentes da arquitetura.

Por limitação de tempo e recursos algumas variáveis que podem alterar os
resultados desse trabalho foram desconsideradas ou fixadas. Esse é o caso de
todas as variáveis de controle e constantes, que poderiam ser trabalhadas como
variáveis independentes. Com isso, os resultados dos experimentos podem ser
diferentes caso sejam usados, por exemplo, um fator de replicação ou uma
quantidade de centros de dados diferentes. Em particular, testes de
escalabilidade serão realizados para entender a influência do tamanho do sistema
nos resultados.

Os experimentos consideram que todos os nós sempre operam sem falhas. Os
resultados de experimentos com o sistema operando em algum modo de falha (desde
a falha de um nó até de um centro de dados inteiro) devem ser diferentes dos
obtidos nesse estudo.

%% ------------------------------------------------------------------------- %%
\subsection{Resultados parciais} \label{sec:resultados_parciais}

Até o momento foram executados alguns testes para um melhor entendimento do
problema sendo tratado e para o estudo e a avaliação das tecnologias usadas nos
experimentos.

Primeiramente foram executados alguns experimentos no Revoada, aglomerado de 8
nós administrado pelo IME - USP. Esses experimentos usaram o Cassandra
\cite{Lakshman2010} como sistema de armazenamento e YCSB \cite{Cooper2010} como
aplicação para execução dos testes, e foram feitos como testes preliminares
sobre o efeito da latência de rede no desempenho de diferentes níveis de
consistência. Os experimentos usaram 3 nós de Cassandra e uma instância do YCSB.
Foram usados os níveis de consistência ONE ($W = 1$ ou $R = 1$), QUORUM ($W =
\lceil(N+1)/2\rceil$ ou $R = \lceil(N+1)/2\rceil)$ e ALL ($W = N$ ou $R = N$) e
latências variando de 0 a 300 ms. O YCSB não estava preparado para lidar com
diferentes configurações de consistência do Cassandra e foi alterado para tal.
Para uma dada latência de rede, foi observado um aumento no tempo de resposta e
diminuição da vazão a medida em que configurações mais rígidas de consistência
foram usadas. Para uma dada configuração de consistência, foi observado um
aumento no tempo de resposta e diminuição da vazão a medida em que a latência de
rede foi aumentada. A preparação e execução desses experimentos colaborou para
um melhor entendimento de ferramentas e técnicas a serem usadas neste trabalho.

Um segundo conjunto de experimentos foi realizado no Grid5000 com três
configurações de consistência implementadas no Riak \cite{Riak}: consistência em
momento indeterminado, consistência na linha do tempo com leituras consistentes
e consistência na linha do tempo com leituras de qualquer versão. Os
experimentos usaram um aglomerado de 6 nós para o Riak, e um nó para o Basho
Bench \cite{Basho}. Os experimentos foram feitos usando latências de 0 a 150 ms.
Foram usadas 3 configurações relativas à distribuição dos nós por centros de
dados: todos os nós no mesmo centro de dados, dois nós em um centro de dados
remoto e quatro nós em um centro de dados remoto (o centro de dados local é o
centro de dados onde a aplicação de execução de testes roda). A carga de
trabalho usada foi uniforme para distribuição das chaves e para alvos dos
acessos. Esses experimentos funcionaram como testes da implementação de
consistência na linha do tempo. Os resultados observados não foram os esperados,
pois indicaram um melhor desempenho da consistência em momento indeterminado,
seguido da consistência na linha do tempo com leituras consistentes e por último
consistência na linha do tempo com leituras de versão qualquer. O resultado
esperado seria que leituras de versão qualquer apresentassem desempenho melhor
do que leituras consistentes. Isso pode ter acontecido por problemas na
implementação ou por algum fator não previsto no funcionamento desses modelos de
consistência. Esse fato precisa ser investigado. Além disso, como esperado, os
experimentos mostraram a existência de conflitos na consistência em momento
indeterminado, enquanto nenhum conflito aconteceu na consistência na linha do
tempo. O impacto desses conflitos no desempenho não foi medido. A partir desses
experimentos foi possível entender o comportamento do Riak no ambiente do
Grid5000, além de servir como prova de conceito da implementação da consistência
na linha do tempo no Riak.

%% ------------------------------------------------------------------------- %%
\subsection{Apresentação dos resultados} \label{sec:apresentacao_dos_resultados}

A comparação de desempenho dos dois modelos de consistência será apresentada em
duas tabelas, uma para os valores obtidos de tempo de resposta e outra para
vazão. Cada linha corresponde a uma carga de trabalho, dada pela tripla
(distribuição de operações, distribuição dos destinos dos acessos, localidade).
Cada latência da rede define uma coluna. Cada célula da tabela apresenta 3
valores: o desempenho da consistência em momento indeterminado, consistência na
linha do tempo com leitura mais recente e consistência na linha do tempo com
leitura qualquer.

Outros valores e gráficos que ajudem na interpretação dos resultados serão
apresentados, como a quantidade de conflitos no caso da consistência em momento
indeterminado.
